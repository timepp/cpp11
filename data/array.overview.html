<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Class template array</title>
</head>
<body>
<h3>
<dfn class="label">[array]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[array]"></object>23.3.2 Class template array </h3>

<h3>
<dfn class="label">[array.overview]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[array.overview]"></object>23.3.2.1 Class template <code class="sh_cpp"><dfn>array</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="array"></object></code> </h3>

<p><a class="anchor" id="p1" href="#p1">1</a>The header <code class="header">&lt;array&gt;</code> defines a class template for storing fixed-size sequences of objects. An
<code class="sh_cpp">array</code> supports random access iterators. An instance of <code class="sh_cpp">array&lt;T, N&gt;</code> stores
<code class="sh_cpp">N</code> elements of type <code class="sh_cpp">T</code>, so that <code class="sh_cpp">size() == N</code> is an invariant. The elements of an
array are stored contiguously, meaning that if <code class="sh_cpp">a</code> is an <code class="sh_cpp">array&lt;T, N&gt;</code> then it obeys
the identity <code class="sh_cpp">&amp;a[n] == &amp;a[0] + n</code> for all <code class="sh_cpp">0 &lt;= n &lt; N</code>.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>An <code class="sh_cpp">array</code> is an aggregate (<a title="dcl.init.aggr" href="dcl.init.aggr.html">8.5.1</a>) that can be initialized with the syntax</p>

<pre><code class="sh_cpp">array&lt;T, N&gt; a = { <i class="nonterminal">initializer-list</i> };</code></pre>

<p>where <i class="nonterminal">initializer-list</i> is a comma-separated list of up to <code class="sh_cpp">N</code> elements whose types are
convertible to <code class="sh_cpp">T</code>.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>An <code class="sh_cpp">array</code> satisfies all of the requirements of a container and of a reversible container
(<a title="container.requirements" href="container.requirements.general.html">23.2</a>), except that a default constructed <code class="sh_cpp">array</code> object is not empty and that <code class="sh_cpp">swap</code>
does not have constant complexity. An <code class="sh_cpp">array</code> satisfies some of the requirements of a sequence container
(<a title="sequence.reqmts" href="sequence.reqmts.html">23.2.3</a>). Descriptions are provided here only for operations on <code class="sh_cpp">array</code> that are not described in
one of these tables and for operations where there is additional semantic information.</p>

<pre><code class="sh_cpp">namespace std {
  template &lt;class T, size_t N&gt;
  struct array {
    // types:
    typedef T&amp;                               reference;
    typedef const T&amp;                         const_reference;
    typedef implementation-defined           iterator;
    typedef implementation-defined           const_iterator;
    typedef size_t                           size_type;
    typedef ptrdiff_t                        difference_type;
    typedef T                                value_type;
    typedef T*                               pointer;
    typedef const T*                         const_pointer;
    typedef reverse_iterator&lt;iterator&gt;       reverse_iterator;
    typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    T       elems[N];           // exposition only

    // no explicit construct/copy/destroy for aggregate type

    void fill(const T&amp; u);
    void swap(array&lt;T, N&gt;&amp;) noexcept(noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;())));

    // iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // capacity:
    constexpr size_type size() noexcept;
    constexpr size_type max_size() noexcept;
    constexpr bool      empty() noexcept;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    T *       data() noexcept;
    const T * data() const noexcept;
  };
}</code></pre>

<p><a class="anchor" id="p4" href="#p4">4</a><span class="note">[ <em>Note:</em> The member variable <code class="sh_cpp">elems</code> is shown for exposition only, to emphasize that <code class="sh_cpp">array</code>
is a class aggregate. The name <code class="sh_cpp">elems</code> is not part of <code class="sh_cpp">array</code>’s interface. — <em>end note</em> ]</span></p>
</body>
</html>

