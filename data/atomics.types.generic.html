<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Atomic types</title>
</head>
<body>
<h2>
<dfn class="label">[atomics.types.generic]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[atomics.types.generic]"></object>29.5 Atomic types </h2>

<pre><code class="sh_cpp">namespace std {
  template &lt;class T&gt; struct <dfn>atomic</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="atomic"></object> {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };

  template &lt;&gt; struct atomic&lt;<var>integral</var>&gt; {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> load(memory_order = memory_order_seq_cst) const volatile noexcept;
    <var>integral</var> load(memory_order = memory_order_seq_cst) const noexcept;
    operator <var>integral</var>() const volatile noexcept;
    operator <var>integral</var>() const noexcept;
    <var>integral</var> exchange(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> exchange(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(<var>integral</var>&amp;, <var>integral</var>, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<var>integral</var>&amp;, <var>integral</var>, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<var>integral</var>&amp;, <var>integral</var>, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<var>integral</var>&amp;, <var>integral</var>, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<var>integral</var>&amp;, <var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(<var>integral</var>&amp;, <var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(<var>integral</var>&amp;, <var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(<var>integral</var>&amp;, <var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> fetch_add(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> fetch_add(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> fetch_sub(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> fetch_sub(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> fetch_and(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> fetch_and(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> fetch_or(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> fetch_or(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;
    <var>integral</var> fetch_xor(<var>integral</var>, memory_order = memory_order_seq_cst) volatile noexcept;
    <var>integral</var> fetch_xor(<var>integral</var>, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<var>integral</var>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <var>integral</var> operator=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator=(<var>integral</var>) noexcept;

    <var>integral</var> operator++(int) volatile noexcept;
    <var>integral</var> operator++(int) noexcept;
    <var>integral</var> operator--(int) volatile noexcept;
    <var>integral</var> operator--(int) noexcept;
    <var>integral</var> operator++() volatile noexcept;
    <var>integral</var> operator++() noexcept;
    <var>integral</var> operator--() volatile noexcept;
    <var>integral</var> operator--() noexcept;
    <var>integral</var> operator+=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator+=(<var>integral</var>) noexcept;
    <var>integral</var> operator-=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator-=(<var>integral</var>) noexcept;
    <var>integral</var> operator&amp;=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator&amp;=(<var>integral</var>) noexcept;
    <var>integral</var> operator|=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator|=(<var>integral</var>) noexcept;
    <var>integral</var> operator^=(<var>integral</var>) volatile noexcept;
    <var>integral</var> operator^=(<var>integral</var>) noexcept;
  };

  template &lt;class T&gt; struct atomic&lt;T*&gt; {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}</code></pre>

<p><a class="anchor" id="p1" href="#p1">1</a>There is a generic class template <code class="sh_cpp">atomic&lt;T&gt;</code>. The type of the template argument
<code class="sh_cpp">T</code> shall be trivially copyable (<a title="basic.types" href="basic.types.html">3.9</a>). <span class="note">[ <em>Note:</em> Type arguments that are not also statically
initializable may be difficult to use. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p2" href="#p2">2</a>The semantics of the operations on specializations of <code class="sh_cpp">atomic</code> are defined in <a title="atomics.types.operations" href="atomics.types.operations.html">29.6</a>.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>Specializations and instantiations of the <code class="sh_cpp">atomic</code> template shall have a deleted copy constructor, a
deleted copy assignment operator, and a constexpr value constructor.</p>

<p><a class="anchor" id="p4" href="#p4">4</a>There shall be full specializations of the <code class="sh_cpp">atomic</code> template for the integral types
<code class="sh_cpp">char</code>, <code class="sh_cpp">signed char</code>, <code class="sh_cpp">unsigned char</code>, <code class="sh_cpp">short</code>, <code class="sh_cpp">unsigned</code>
<code class="sh_cpp">short</code>, <code class="sh_cpp">int</code>, <code class="sh_cpp">unsigned int</code>, <code class="sh_cpp">long</code>, <code class="sh_cpp">unsigned long</code>,
<code class="sh_cpp">long long</code>, <code class="sh_cpp">unsigned long long</code>, <code class="sh_cpp">char16</code>_<code class="sh_cpp">t</code>,
<code class="sh_cpp">char32</code>_<code class="sh_cpp">t</code>, <code class="sh_cpp">wchar</code>_<code class="sh_cpp">t</code>, and any other types needed by the typedefs in the
header <code class="header">&lt;cstdint&gt;</code>. For each integral type <var>integral</var>, the specialization
<code class="sh_cpp">atomic&lt;<var>integral</var>&gt;</code> provides additional atomic operations appropriate to integral types.
There shall be a specialization <code class="sh_cpp">atomic&lt;bool&gt;</code> which provides the general atomic operations as
specified in <a title="atomics.types.operations.general" href="atomics.types.operations.general.html">29.6.1</a>.</p>

<p><a class="anchor" id="p5" href="#p5">5</a>The atomic integral specializations and the specialization <code class="sh_cpp">atomic&lt;bool&gt;</code> shall have
standard layout. They shall each have a trivial default constructor and a trivial destructor. They shall each support
aggregate initialization syntax.</p>

<p><a class="anchor" id="p6" href="#p6">6</a>There shall be pointer partial specializations of the <code class="sh_cpp">atomic</code> class template. These specializations
shall have standard layout, trivial default constructors, and trivial destructors. They shall each support aggregate
initialization syntax.</p>

<p><a class="anchor" id="p7" href="#p7">7</a>There shall be named types corresponding to the integral specializations of <code class="sh_cpp">atomic</code>, as specified
in Table <a href="atomics.types.generic.html#t145">145</a>, and a named type <code class="sh_cpp">atomic_bool</code> corresponding to the specified
<code class="sh_cpp">atomic&lt;bool&gt;</code>. Each named type is either a typedef to the corresponding specialization or a base class
of the corresponding specialization. If it is a base class, it shall support the same member functions as the
corresponding specialization.</p>

<table id="t145" class="bordered headed">
<caption>Table 145 — <code class="sh_cpp">atomic</code> integral typedefs</caption>
<thead><tr>
<th>Named type</th>
<th>Integral argument type</th>
</tr></thead>
<tbody>
<tr>
<td><code class="sh_cpp">atomic_char</code></td>
<td><code class="sh_cpp">char</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_schar</code></td>
<td><code class="sh_cpp">signed char</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uchar</code></td>
<td><code class="sh_cpp">unsigned char</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_short</code></td>
<td><code class="sh_cpp">short</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_ushort</code></td>
<td><code class="sh_cpp">unsigned short</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int</code></td>
<td><code class="sh_cpp">int</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint</code></td>
<td><code class="sh_cpp">unsigned int</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_long</code></td>
<td><code class="sh_cpp">long</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_ulong</code></td>
<td><code class="sh_cpp">unsigned long</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_llong</code></td>
<td><code class="sh_cpp">long long</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_ullong</code></td>
<td><code class="sh_cpp">unsigned long long</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_char16_t</code></td>
<td><code class="sh_cpp">char16_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_char32_t</code></td>
<td><code class="sh_cpp">char32_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_wchar_t</code></td>
<td><code class="sh_cpp">wchar_t</code></td>
</tr>
</tbody>
</table>

<p><a class="anchor" id="p8" href="#p8">8</a>There shall be atomic typedefs corresponding to the typedefs in the header <code class="header">&lt;inttypes.h&gt;</code> as
specified in Table <a href="atomics.types.generic.html#t146">146</a>.</p>

<p><a class="anchor" id="p9" href="#p9">9</a><span class="note">[ <em>Note:</em> The representation of an atomic specialization need not have the same size as its corresponding argument
type. Specializations should have the same size whenever possible, as this reduces the effort required to port existing
code. — <em>end note</em> ]</span></p>

<table id="t146" class="bordered headed padded">
<caption>Table 146 — <code class="sh_cpp">atomic</code> <code class="header">&lt;inttypes.h&gt;</code> typedefs</caption>
<thead><tr>
<th>Atomic typedef</th>
<th>
<code class="header">&lt;inttypes.h&gt;</code> type</th>
</tr></thead>
<tbody>
<tr>
<td><code class="sh_cpp">atomic_int_least8_t</code></td>
<td><code class="sh_cpp">int_least8_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_least8_t</code></td>
<td><code class="sh_cpp">uint_least8_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_least16_t</code></td>
<td><code class="sh_cpp">int_least16_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_least16_t</code></td>
<td><code class="sh_cpp">uint_least16_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_least32_t</code></td>
<td><code class="sh_cpp">int_least32_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_least32_t</code></td>
<td><code class="sh_cpp">uint_least32_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_least64_t</code></td>
<td><code class="sh_cpp">int_least64_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_least64_t</code></td>
<td><code class="sh_cpp">uint_least64_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_fast8_t</code></td>
<td><code class="sh_cpp">int_fast8_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_fast8_t</code></td>
<td><code class="sh_cpp">uint_fast8_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_fast16_t</code></td>
<td><code class="sh_cpp">int_fast16_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_fast16_t</code></td>
<td><code class="sh_cpp">uint_fast16_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_fast32_t</code></td>
<td><code class="sh_cpp">int_fast32_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_fast32_t</code></td>
<td><code class="sh_cpp">uint_fast32_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_int_fast64_t</code></td>
<td><code class="sh_cpp">int_fast64_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uint_fast64_t</code></td>
<td><code class="sh_cpp">uint_fast64_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_intptr_t</code></td>
<td><code class="sh_cpp">intptr_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uintptr_t</code></td>
<td><code class="sh_cpp">uintptr_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_size_t</code></td>
<td><code class="sh_cpp">size_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_ptrdiff_t</code></td>
<td><code class="sh_cpp">ptrdiff_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_intmax_t</code></td>
<td><code class="sh_cpp">intmax_t</code></td>
</tr>
<tr>
<td><code class="sh_cpp">atomic_uintmax_t</code></td>
<td><code class="sh_cpp">uintmax_t</code></td>
</tr>
</tbody>
</table>
</body>
</html>

