<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Fundamental types</title>
</head>
<body>
<h3>
<dfn class="label">[basic.fundamental]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[basic.fundamental]"></object>3.9.1 Fundamental types </h3>

<p><a class="anchor" id="p1" href="#p1">1</a>Objects declared as characters (<code class="sh_cpp">char</code>) shall be large enough to store any member of the
implementation’s basic character set. If a character from this set is stored in a character object, the integral value
of that character object is equal to the value of the single character literal form of that character. It is
implementation-defined whether a <code class="sh_cpp">char</code> object can hold negative values. Characters can be explicitly
declared <code class="sh_cpp">unsigned</code> or <code class="sh_cpp">signed</code>. Plain <code class="sh_cpp">char</code>, <code class="sh_cpp">signed char</code>, and
<code class="sh_cpp">unsigned char</code> are three distinct types. A <code class="sh_cpp">char</code>, a <code class="sh_cpp">signed char</code>, and an
<code class="sh_cpp">unsigned char</code> occupy the same amount of storage and have the same alignment requirements (<a title="basic.align" href="basic.align.html">3.11</a>);
that is, they have the same object representation. For character types, all bits of the object representation
participate in the value representation. For unsigned character types, all possible bit patterns of the value
representation represent numbers. These requirements do not hold for other types. In any particular implementation, a
plain <code class="sh_cpp">char</code> object can take on either the same values as a <code class="sh_cpp">signed char</code> or an <code class="sh_cpp">unsigned
char</code>; which one is implementation-defined.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>There are five <dfn>standard signed integer types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="standard signed integer types"></object>: “<code class="sh_cpp">signed char</code>”, “<code class="sh_cpp">short int</code>”,
“<code class="sh_cpp">int</code>”, “<code class="sh_cpp">long int</code>”, and “<code class="sh_cpp">long long int</code>”. In this list, each type provides at least
as much storage as those preceding it in the list. There may also be implementation-defined <dfn>extended signed integer
types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="extended signed integer
types"></object>. The standard and extended signed integer types are collectively called <dfn>signed integer types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="signed integer types"></object>.
Plain <code class="sh_cpp">int</code>s have the natural size suggested by the architecture of the execution environment<sup class="footnote"><a href="#fn44">44</a></sup>;
the other signed integer types are provided to meet special needs.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>For each of the standard signed integer types, there exists a corresponding (but different) <dfn>standard
unsigned integer type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="standard
unsigned integer type"></object>: “<code class="sh_cpp">unsigned char</code>”, “<code class="sh_cpp">unsigned short int</code>”, “<code class="sh_cpp">unsigned
int</code>”, “<code class="sh_cpp">unsigned long int</code>”, and “<code class="sh_cpp">unsigned long long int</code>”, each of which occupies the
same amount of storage and has the same alignment requirements (<a title="basic.align" href="basic.align.html">3.11</a>) as the corresponding signed integer
type<sup class="footnote"><a href="#fn45">45</a></sup>; that is, each signed integer type has the same object representation as its corresponding unsigned
integer type. Likewise, for each of the extended signed integer types there exists a corresponding <dfn>extended
unsigned integer type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="extended
unsigned integer type"></object> with the same amount of storage and alignment requirements. The standard and extended
unsigned integer types are collectively called <dfn>unsigned integer types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="unsigned integer types"></object>. The range of non-negative values of a
signed integer type is a subrange of the corresponding unsigned integer type, and the value representation of each
corresponding signed/unsigned type shall be the same. The standard signed integer types and standard unsigned integer
types are collectively called the <dfn>standard integer types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="standard integer types"></object>, and the extended signed integer types and extended
unsigned integer types are collectively called the <dfn>extended integer types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="extended integer types"></object>.</p>

<p><a class="anchor" id="p4" href="#p4">4</a>Unsigned integers, declared <code class="sh_cpp">unsigned</code>, shall obey the laws of arithmetic modulo
2<sup><var>n</var></sup> where <var>n</var> is the number of bits in the value representation of that particular size of
integer.<sup class="footnote"><a href="#fn46">46</a></sup></p>

<p><a class="anchor" id="p5" href="#p5">5</a>Type <code class="sh_cpp">wchar_t</code> is a distinct type whose values can represent distinct codes for all members of the
largest extended character set specified among the supported locales (<a title="locale" href="locale.html">22.3.1</a>). Type <code class="sh_cpp">wchar_t</code>
shall have the same size, signedness, and alignment requirements (<a title="basic.align" href="basic.align.html">3.11</a>) as one of the other integral types,
called its <dfn>underlying type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="underlying type"></object>. Types <code class="sh_cpp">char16_t</code> and <code class="sh_cpp">char32_t</code> denote distinct types with
the same size, signedness, and alignment as <code class="sh_cpp">uint_least16_t</code> and <code class="sh_cpp">uint_least32_t</code>, respectively,
in <code class="header">&lt;stdint.h&gt;</code>, called the underlying types.</p>

<p><a class="anchor" id="p6" href="#p6">6</a>Values of type <code class="sh_cpp">bool</code> are either <code class="sh_cpp">true</code> or <code class="sh_cpp">false</code>.<sup class="footnote"><a href="#fn47">47</a></sup> <span class="note">[ <em>Note:</em> There
are no <code class="sh_cpp">signed</code>, <code class="sh_cpp">unsigned</code>, <code class="sh_cpp">short</code>, or <code class="sh_cpp">long</code> <code class="sh_cpp">bool</code> types or
values. — <em>end note</em> ]</span> Values of type <code class="sh_cpp">bool</code> participate in integral promotions (<a title="conv.prom" href="conv.prom.html">4.5</a>).</p>

<p><a class="anchor" id="p7" href="#p7">7</a>Types <code class="sh_cpp">bool</code>, <code class="sh_cpp">char</code>, <code class="sh_cpp">char16_t</code>, <code class="sh_cpp">char32_t</code>, <code class="sh_cpp">wchar_t</code>,
and the signed and unsigned integer types are collectively called <dfn>integral types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="integral types"></object>.<sup class="footnote"><a href="#fn48">48</a></sup> A synonym for
integral type is <dfn>integer type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="integer type"></object>. The representations of integral types shall define values by use of a pure
binary numeration system.<sup class="footnote"><a href="#fn49">49</a></sup> <span class="example">[ <em>Example:</em> this International Standard permits 2’s complement, 1’s complement and
signed magnitude representations for integral types. — <em>end example</em> ]</span></p>

<p><a class="anchor" id="p8" href="#p8">8</a>There are three <dfn>floating point</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="floating point"></object> types: <code class="sh_cpp">float</code>, <code class="sh_cpp">double</code>, and <code class="sh_cpp">long
double</code>. The type <code class="sh_cpp">double</code> provides at least as much precision as <code class="sh_cpp">float</code>, and the type
<code class="sh_cpp">long double</code> provides at least as much precision as <code class="sh_cpp">double</code>. The set of values of the type
<code class="sh_cpp">float</code> is a subset of the set of values of the type <code class="sh_cpp">double</code>; the set of values of the type
<code class="sh_cpp">double</code> is a subset of the set of values of the type <code class="sh_cpp">long double</code>. The value representation of
floating-point types is implementation-defined. Integral and floating types are collectively called <dfn>arithmetic
types</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="arithmetic
types"></object>. Specializations of the standard template <code class="sh_cpp">std::numeric_limits</code> (<a title="support.limits" href="support.limits.general.html">18.3</a>) shall specify
the maximum and minimum values of each arithmetic type for an implementation.</p>

<p><a class="anchor" id="p9" href="#p9">9</a>The <code class="sh_cpp">void</code> type has an empty set of values. The <code class="sh_cpp">void</code> type is an incomplete type that
cannot be completed. It is used as the return type for functions that do not return a value. Any expression can be
explicitly converted to type <var>cv</var> <code class="sh_cpp">void</code> (<a title="expr.cast" href="expr.cast.html">5.4</a>). An expression of type <code class="sh_cpp">void</code>
shall be used only as an expression statement (<a title="stmt.expr" href="stmt.expr.html">6.2</a>), as an operand of a comma expression (<a title="expr.comma" href="expr.comma.html">5.18</a>),
as a second or third operand of <code class="sh_cpp">?:</code> (<a title="expr.cond" href="expr.cond.html">5.16</a>), as the operand of <code class="sh_cpp">typeid</code> or
<code class="sh_cpp">decltype</code>, as the expression in a return statement (<a title="stmt.return" href="stmt.return.html">6.6.3</a>) for a function with the return type
<code class="sh_cpp">void</code>, or as the operand of an explicit conversion to type <var>cv</var> <code class="sh_cpp">void</code>.</p>

<p><a class="anchor" id="p10" href="#p10">10</a>A value of type <code class="sh_cpp">std::nullptr_t</code> is a null pointer constant (<a title="conv.ptr" href="conv.ptr.html">4.10</a>). Such values
participate in the pointer and the pointer to member conversions (<a title="conv.ptr" href="conv.ptr.html">4.10</a>, <a title="conv.mem" href="conv.mem.html">4.11</a>).
<code class="sh_cpp">sizeof(std::nullptr_t)</code> shall be equal to <code class="sh_cpp">sizeof(void*)</code>.</p>

<p><a class="anchor" id="p11" href="#p11">11</a><span class="note">[ <em>Note:</em> Even if the implementation defines two or more basic types to have the same value representation, they
are nevertheless different types. — <em>end note</em> ]</span></p>












<div>
<p class="footnote" id="fn44">44) that is, large enough to contain any value in the range of <code class="sh_cpp">INT_MIN</code> and
<code class="sh_cpp">INT_MAX</code>, as defined in the header <code class="header">&lt;climits&gt;</code>.</p>
<p class="footnote" id="fn45">45) See <a title="dcl.type.simple" href="dcl.type.simple.html">7.1.6.2</a> regarding the correspondence between types and the sequences of
<i class="nonterminal">type-specifier</i>s that designate them.</p>
<p class="footnote" id="fn46">46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by
the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be
represented by the resulting unsigned integer type.</p>
<p class="footnote" id="fn47">47) Using a <code class="sh_cpp">bool</code> value in ways described by this International Standard as “undefined”, such
as by examining the value of an uninitialized automatic object, might cause it to behave as if it is neither
<code class="sh_cpp">true</code> nor <code class="sh_cpp">false</code>.</p>
<p class="footnote" id="fn48">48) Therefore, enumerations (<a title="dcl.enum" href="dcl.enum.html">7.2</a>) are not integral; however, enumerations can be promoted to
integral types as specified in <a title="conv.prom" href="conv.prom.html">4.5</a>.</p>
<p class="footnote" id="fn49">49) A positional representation for integers that uses the binary digits 0 and 1, in which the values
represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except
perhaps for the bit with the highest position. (Adapted from the American National Dictionary for Information Processing
Systems.)</p>
</div>
</body>
</html>

