<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<!--[IF IE]>
	<script type="text/javascript" src="ierange.js"></script>
<![ENDIF]-->
<script type="text/javascript" src="../masha.min.js"></script>
<script type="text/javascript" src="../all_pack.js"></script>
<link rel="stylesheet" type="text/css" href="../css/masha.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<link rel="stylesheet" type="text/css" href="../styles.css">
<script type="text/javascript" src="../page.js"></script>

<title>Class members</title>
</head>
<body>
<h2>
<dfn class="label">[class.mem]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[class.mem]"></object>9.2 Class members </h2>
<dl>
<dt>
<dfn><i class="nonterminal">member-specification</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="member-specification"></object>:</dt>
	<dd>
<i class="nonterminal">member-declaration</i> <i class="nonterminal">member-specification</i><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">access-specifier</i> <code class="sh_cpp">:</code> <i class="nonterminal">member-specification</i><sub class="opt">opt</sub>
</dd>
<dt>
<dfn><i class="nonterminal">member-declaration</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="member-declaration"></object>:</dt>
	<dd>
<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">decl-specifier-seq</i><sub class="opt">opt</sub>
		<i class="nonterminal">member-declarator-list</i><sub class="opt">opt</sub> <code class="sh_cpp">;</code>
</dd>
	<dd>
<i class="nonterminal">function-definition</i> <code class="sh_cpp">;</code><sub class="opt">opt</sub>
</dd>
	<dd><i class="nonterminal">using-declaration</i></dd>
	<dd><i class="nonterminal">static_assert-declaration</i></dd>
	<dd><i class="nonterminal">template-declaration</i></dd>
	<dd><i class="nonterminal">alias-declaration</i></dd>
<dt>
<dfn><i class="nonterminal">member-declarator-list</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="member-declarator-list"></object>:</dt>
	<dd><i class="nonterminal">member-declarator</i></dd>
	<dd>
<i class="nonterminal">member-declarator-list</i> <code class="sh_cpp">,</code> <i class="nonterminal">member-declarator</i>
</dd>
<dt>
<dfn><i class="nonterminal">member-declarator</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="member-declarator"></object>:</dt>
	<dd>
<i class="nonterminal">declarator</i> <i class="nonterminal">virt-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">pure-specifier</i><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">declarator</i> <i class="nonterminal">brace-or-equal-initializer</i><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">identifier</i><sub class="opt">opt</sub> <i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <code class="sh_cpp">:</code> <i class="nonterminal">constant-expression</i>
</dd>
<dt>
<dfn><i class="nonterminal">virt-specifier-seq</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="virt-specifier-seq"></object>:</dt>
	<dd><i class="nonterminal">virt-specifier</i></dd>
	<dd>
<i class="nonterminal">virt-specifier-seq</i> <i class="nonterminal">virt-specifier</i>
</dd>
<dt>
<dfn><i class="nonterminal">virt-specifier</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="virt-specifier"></object>:</dt>
	<dd><code class="sh_cpp">override</code></dd>
	<dd><code class="sh_cpp">final</code></dd>
<dt>
<dfn><i class="nonterminal">pure-specifier</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="pure-specifier"></object>:</dt>
	<dd>
<code class="sh_cpp">=</code> <code class="sh_cpp">0</code>
</dd>
</dl>

<p><a class="anchor" id="p1" href="#p1">1</a>The <i class="nonterminal">member-specification</i> in a class definition declares the full set of members of the class; no
member can be added elsewhere. Members of a class are data members, member functions (<a title="class.mfct" href="class.mfct.html">9.3</a>), nested types, and
enumerators. Data members and member functions are static or non-static; see <a title="class.static" href="class.static.html">9.4</a>. Nested types are classes
(<a title="class.name" href="class.name.html">9.1</a>, <a title="class.nest" href="class.nest.html">9.7</a>) and enumerations (<a title="dcl.enum" href="dcl.enum.html">7.2</a>) defined in the class, and arbitrary types declared as
members by use of a typedef declaration (<a title="dcl.typedef" href="dcl.typedef.html">7.1.3</a>). The enumerators of an unscoped enumeration (<a title="dcl.enum" href="dcl.enum.html">7.2</a>)
defined in the class are members of the class. Except when used to declare friends (<a title="class.friend" href="class.friend.html">11.3</a>) or to introduce the
name of a member of a base class into a derived class (<a title="namespace.udecl" href="namespace.udecl.html">7.3.3</a>), <i class="nonterminal">member-declaration</i>s declare members
of the class, and each such <i class="nonterminal">member-declaration</i> shall declare at least one member name of the class. A member
shall not be declared twice in the <i class="nonterminal">member-specification</i>, except that a nested class or member class template
can be declared and then later defined, and except that an enumeration can be introduced with an
<i class="nonterminal">opaque-enum-declaration</i> and later redeclared with an <i class="nonterminal">enum-specifier</i>.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>A class is considered a completely-defined object type (<a title="basic.types" href="basic.types.html">3.9</a>) (or complete type) at the closing
<code class="sh_cpp">}</code> of the <i class="nonterminal">class-specifier</i>. Within the class <i class="nonterminal">member-specification</i>, the class is regarded as
complete within function bodies, default arguments, <i class="nonterminal">exception-specification</i>s, and
<i class="nonterminal">brace-or-equal-initializer</i>s for non-static data mem- bers (including such things in nested classes). Otherwise
it is regarded as incomplete within its own class <i class="nonterminal">member-specification</i>.</p>

<p><a class="anchor" id="p3" href="#p3">3</a><span class="note">[ <em>Note:</em> A single name can denote several function members provided their types are sufficiently different (Clause
<a title="over" href="over.html">13</a>). — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p4" href="#p4">4</a>A member can be initialized using a constructor; see <a title="class.ctor" href="class.ctor.html">12.1</a>. <span class="note">[ <em>Note:</em> See Clause <a title="special" href="special.html">12</a> for a
description of constructors and other special member functions. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p5" href="#p5">5</a>A member can be initialized using a <i class="nonterminal">brace-or-equal-initializer</i>. (For static data members, see
<a title="class.static.data" href="class.static.data.html">9.4.2</a>; for non-static data members, see <a title="class.base.init" href="class.base.init.html">12.6.2</a>).</p>

<p><a class="anchor" id="p6" href="#p6">6</a>A member shall not be declared with the <code class="sh_cpp">extern</code> or <code class="sh_cpp">register</code>
<i class="nonterminal">storage-class-specifier</i>. Within a class definition, a member shall not be declared with the
<code class="sh_cpp">thread_local</code> <i class="nonterminal">storage-class-specifier</i> unless also declared <code class="sh_cpp">static</code>.</p>

<p><a class="anchor" id="p7" href="#p7">7</a>The <i class="nonterminal">decl-specifier-seq</i> may be omitted in constructor, destructor, and conversion function declarations
only; when declaring another kind of member the <i class="nonterminal">decl-specifier-seq</i> shall contain a <i class="nonterminal">type-specifier</i> that
is not a <i class="nonterminal">cv-qualifier</i>. The <i class="nonterminal">member-declarator-list</i> can be omitted only after a <i class="nonterminal">class-specifier</i>
or an <i class="nonterminal">enum-specifier</i> or in a <code class="sh_cpp">friend</code> declaration (<a title="class.friend" href="class.friend.html">11.3</a>). A <i class="nonterminal">pure-specifier</i> shall
be used only in the declaration of a virtual function (<a title="class.virtual" href="class.virtual.html">10.3</a>).</p>

<p><a class="anchor" id="p8" href="#p8">8</a>The optional <i class="nonterminal">attribute-specifier-seq</i> in a <i class="nonterminal">member-declaration</i> appertains to each of the
entities declared by the <i class="nonterminal">member-declarator</i>s; it shall not appear if the optional
<i class="nonterminal">member-declarator-list</i> is omitted.</p>

<p><a class="anchor" id="p9" href="#p9">9</a>A <i class="nonterminal">virt-specifier-seq</i> shall contain at most one of each <i class="nonterminal">virt-specifier</i>. A
<i class="nonterminal">virt-specifier-seq</i> shall appear only in the declaration of a virtual member function (<a title="class.virtual" href="class.virtual.html">10.3</a>).</p>

<p><a class="anchor" id="p10" href="#p10">10</a>Non-<code class="sh_cpp">static</code> (<a title="class.static" href="class.static.html">9.4</a>) data members shall not have incomplete types. In particular, a class
<code class="sh_cpp">C</code> shall not contain a non-static member of class <code class="sh_cpp">C</code>, but it can contain a pointer or reference
to an object of class <code class="sh_cpp">C</code>.</p>

<p><a class="anchor" id="p11" href="#p11">11</a><span class="note">[ <em>Note:</em> See <a title="expr.prim" href="expr.prim.general.html">5.1</a> for restrictions on the use of non-static data members and non-static member
functions. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p12" href="#p12">12</a><span class="note">[ <em>Note:</em> The type of a non-static member function is an ordinary function type, and the type of a non-static data
member is an ordinary object type. There are no special member function types or data member types. — <em>end note</em> ]</span></p>

<div class="example">
<p><a class="anchor" id="p13" href="#p13">13</a>[ <em>Example:</em> A simple example of a class definition is</p>

<pre><code class="sh_cpp">struct tnode {
  char tword[20];
  int count;
  tnode *left;
  tnode *right;
};</code></pre>

<p>which contains an array of twenty characters, an integer, and two pointers to objects of the same type. Once this
definition has been given, the declaration</p>

<pre><code class="sh_cpp">tnode s, *sp;</code></pre>

<p>declares <code class="sh_cpp">s</code> to be a <code class="sh_cpp">tnode</code> and <code class="sh_cpp">sp</code> to be a pointer to a <code class="sh_cpp">tnode</code>. With
these declarations, <code class="sh_cpp">sp-&gt;count</code> refers to the <code class="sh_cpp">count</code> member of the object to which
<code class="sh_cpp">sp</code> points; <code class="sh_cpp">s.left</code> refers to the <code class="sh_cpp">left</code> subtree pointer of the object
<code class="sh_cpp">s</code>; and <code class="sh_cpp">s.right-&gt;tword[0]</code> refers to the initial character of the <code class="sh_cpp">tword</code> member
of the right subtree of <code class="sh_cpp">s</code>. — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p14" href="#p14">14</a>Nonstatic data members of a (non-union) class with the same access control (Clause <a title="class.access" href="class.access.html">11</a>) are
allocated so that later members have higher addresses within a class object. The order of allocation of non-static data
members with different access control is unspecified (<a title="class.access" href="class.access.html">11</a>). Implementation alignment requirements might cause
two adjacent members not to be allocated immediately after each other; so might requirements for space for managing
virtual functions (<a title="class.virtual" href="class.virtual.html">10.3</a>) and virtual base classes (<a title="class.mi" href="class.mi.html">10.1</a>).</p>

<p><a class="anchor" id="p15" href="#p15">15</a>If <code class="sh_cpp">T</code> is the name of a class, then each of the following shall have a name different from
<code class="sh_cpp">T</code>:</p>
<ul>
<li>every static data member of class <code class="sh_cpp">T</code>;</li>
<li>every member function of class <code class="sh_cpp">T</code> <span class="note">[ <em>Note:</em> This restriction does not apply to constructors, which do not
	have names (<a title="class.ctor" href="class.ctor.html">12.1</a>) — <em>end note</em> ]</span>;</li>
<li>every member of class <code class="sh_cpp">T</code> that is itself a type;</li>
<li>every enumerator of every member of class <code class="sh_cpp">T</code> that is an unscoped enumerated type; and</li>
<li>every member of every anonymous union that is a member of class <code class="sh_cpp">T</code>.</li>
</ul>

<p><a class="anchor" id="p16" href="#p16">16</a>In addition, if class <code class="sh_cpp">T</code> has a user-declared constructor (<a title="class.ctor" href="class.ctor.html">12.1</a>), every non-static data
member of class <code class="sh_cpp">T</code> shall have a name different from <code class="sh_cpp">T</code>.</p>

<p><a class="anchor" id="p17" href="#p17">17</a>Two standard-layout struct (Clause <a title="class" href="class.html">9</a>) types are layout-compatible if they have the same number of
non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types
(<a title="basic.types" href="basic.types.html">3.9</a>).</p>

<p><a class="anchor" id="p18" href="#p18">18</a>Two standard-layout union (Clause <a title="class" href="class.html">9</a>) types are layout-compatible if they have the same number of
non-static data members and corresponding non-static data members (in any order) have layout-compatible types
(<a title="basic.types" href="basic.types.html">3.9</a>).</p>

<p><a class="anchor" id="p19" href="#p19">19</a>If a standard-layout union contains two or more standard-layout structs that share a common initial sequence,
and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to
inspect the common initial part of any of them. Two standard-layout structs share a common initial sequence if
corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with
the same width for a sequence of one or more initial members.</p>

<p><a class="anchor" id="p20" href="#p20">20</a>A pointer to a standard-layout struct object, suitably converted using a <code class="sh_cpp">reinterpret_cast</code>, points
to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.
<span class="note">[ <em>Note:</em> There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as
necessary to achieve appropriate alignment. — <em>end note</em> ]</span></p>
</body>
</html>



