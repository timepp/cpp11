<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Arrays</title>
</head>
<body>
<h3>
<dfn class="label">[dcl.array]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[dcl.array]"></object>8.3.4 Arrays </h3>

<p><a class="anchor" id="p1" href="#p1">1</a>In a declaration <code class="sh_cpp">T</code> <code class="sh_cpp">D</code> where <code class="sh_cpp">D</code> has the form</p>

<dl><dd>
<code class="sh_cpp">D1</code> <code class="sh_cpp">[</code> <i class="nonterminal">constant-expression</i><sub class="opt">opt</sub> <code class="sh_cpp">]</code> <i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub>
</dd></dl>

<p>and the type of the identifier in the declaration <code class="sh_cpp">T D1</code> is “<i class="nonterminal">derived-declarator-type-list</i>
<code class="sh_cpp">T</code>”, then the type of the identifier of <code class="sh_cpp">D</code> is an array type; if the type of the identifier of
<code class="sh_cpp">D</code> contains the <code class="sh_cpp">auto</code> <i class="nonterminal">type-specifier</i>, the program is ill-formed. <code class="sh_cpp">T</code> is
called the array <dfn>element type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="element type"></object>; this type shall not be a reference type, the (possibly cv-qualified) type
<code class="sh_cpp">void</code>, a function type or an abstract class type. If the <i class="nonterminal">constant-expression</i> (<a title="expr.const" href="expr.const.html">5.19</a>) is
present, it shall be an integral constant expression and its value shall be greater than zero. The constant expression
specifies the <dfn>bound</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="bound"></object> of (number of elements in) the array. If the value of the constant expression is
<code class="sh_cpp">N</code>, the array has <code class="sh_cpp">N</code> elements numbered <code class="sh_cpp">0</code> to <code class="sh_cpp">N-1</code>, and the type of the
identifier of <code class="sh_cpp">D</code> is “<i class="nonterminal">derived-declarator-type-list</i> array of <code class="sh_cpp">N</code> <code class="sh_cpp">T</code>”. An
object of array type contains a contiguously allocated non-empty set of <code class="sh_cpp">N</code> subobjects of type
<code class="sh_cpp">T</code>. Except as noted below, if the constant expression is omitted, the type of the identifier of
<code class="sh_cpp">D</code> is “<i class="nonterminal">derived-declarator-type-list</i> array of unknown bound of <code class="sh_cpp">T</code>”, an incomplete object
type. The type “<i class="nonterminal">derived-declarator-type-list</i> array of <code class="sh_cpp">N</code> <code class="sh_cpp">T</code>” is a different type from
the type “<i class="nonterminal">derived-declarator-type-list</i> array of unknown bound of <code class="sh_cpp">T</code>”, see <a title="basic.types" href="basic.types.html">3.9</a>. Any type
of the form “<i class="nonterminal">cv-qualifier-seq</i> array of <code class="sh_cpp">N</code> <code class="sh_cpp">T</code>” is adjusted to “array of <code class="sh_cpp">N</code>
<i class="nonterminal">cv-qualifier-seq</i> <code class="sh_cpp">T</code>”, and similarly for “array of unknown bound of <code class="sh_cpp">T</code>”. The optional
<i class="nonterminal">attribute-specifier-seq</i> appertains to the array.</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">typedef int A[5], AA[2][3];
typedef const A CA;         // type is “array of 5 const int”
typedef const AA CAA;       // type is “array of 2 array of 3 const int”</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><span class="note">[ <em>Note:</em> An “array of <code class="sh_cpp">N</code> <i class="nonterminal">cv-qualifier-seq</i> <code class="sh_cpp">T</code>” has cv-qualified type; see
<a title="basic.type.qualifier" href="basic.type.qualifier.html">3.9.3</a>. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p2" href="#p2">2</a>An array can be constructed from one of the fundamental types (except <code class="sh_cpp">void</code>), from a pointer, from
a pointer to member, from a class, from an enumeration type, or from another array.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>When several “array of” specifications are adjacent, a multidimensional array is created; only the first of the
constant expressions that specify the bounds of the arrays may be omitted. In addition to declarations in which an
incomplete object type is allowed, an array bound may be omitted in some cases in the declaration of a function
parameter (<a title="dcl.fct" href="dcl.fct.html">8.3.5</a>). An array bound may also be omitted when the declarator is followed by an
<i class="nonterminal">initializer</i> (<a title="dcl.init" href="dcl.init.html">8.5</a>). In this case the bound is calculated from the number of initial elements (say,
<code class="sh_cpp">N</code>) supplied (<a title="dcl.init.aggr" href="dcl.init.aggr.html">8.5.1</a>), and the type of the identifier of <code class="sh_cpp">D</code> is “array of
<code class="sh_cpp">N</code> <code class="sh_cpp">T</code>”. Furthermore, if there is a preceding declaration of the entity in the same scope in
which the bound was specified, an omitted array bound is taken to be the same as in that earlier declaration, and
similarly for the definition of a static data member of a class.</p>

<div class="example">
<p><a class="anchor" id="p4" href="#p4">4</a>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">float fa[17], *afp[17];</code></pre>

<p>declares an array of <code class="sh_cpp">float</code> numbers and an array of pointers to <code class="sh_cpp">float</code> numbers. For another example,</p>

<pre><code class="sh_cpp">static int x3d[3][5][7];</code></pre>

<p>declares a static three-dimensional array of integers, with rank 3 × 5 × 7. In complete detail, <code class="sh_cpp">x3d</code> is
an array of three items; each item is an array of five arrays; each of the latter arrays is an array of seven integers.
Any of the expressions <code class="sh_cpp">x3d</code>, <code class="sh_cpp">x3d[i]</code>, <code class="sh_cpp">x3d[i][j]</code>, <code class="sh_cpp">x3d[i][j][k]</code> can
reasonably appear in an expression. Finally,</p>

<pre><code class="sh_cpp">extern int x[10];
struct S {
  static int y[10];
};

int x[];                // OK: bound is 10
int S::y[];             // OK: bound is 10

void f() {
  extern int x[];
  int i = sizeof(x);    // error: incomplete object type
}</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p5" href="#p5">5</a><span class="note">[ <em>Note:</em> conversions affecting expressions of array type are described in <a title="conv.array" href="conv.array.html">4.2</a>. Objects of array types
cannot be modified, see <a title="basic.lval" href="basic.lval.html">3.10</a>. — <em>end note</em> ]</span></p>

<div class="note">
<p><a class="anchor" id="p6" href="#p6">6</a>[ <em>Note:</em> Except where it has been declared for a class (<a title="over.sub" href="over.sub.html">13.5.5</a>), the subscript operator <code class="sh_cpp">[]</code>
is interpreted in such a way that <code class="sh_cpp">E1[E2]</code> is identical to <code class="sh_cpp">*((E1)+(E2))</code>. Because of the
conversion rules that apply to <code class="sh_cpp">+</code>, if <code class="sh_cpp">E1</code> is an array and <code class="sh_cpp">E2</code> an integer, then
<code class="sh_cpp">E1[E2]</code> refers to the <code class="sh_cpp">E2</code>-th member of <code class="sh_cpp">E1</code>. Therefore, despite its asymmetric
appearance, subscripting is a commutative operation.</p>

<p><a class="anchor" id="p7" href="#p7">7</a>A consistent rule is followed for multidimensional arrays. If <code class="sh_cpp">E</code> is an <var>n</var>-dimensional
array of rank <var>i</var> × <var>j</var> × … × <var>k</var>, then <code class="sh_cpp">E</code> appearing in an expression that is
subject to the array-to-pointer conversion (<a title="conv.array" href="conv.array.html">4.2</a>) is converted to a pointer to an (<var>n</var>−1)-dimensional
array with rank <var>j</var> × … × <var>k</var>. If the <code class="sh_cpp">*</code> operator, either explicitly or implicitly as a
result of subscripting, is applied to this pointer, the result is the pointed-to (<var>n</var>−1)-dimensional array,
which itself is immediately converted into a pointer.</p>

<div class="example">
<p><a class="anchor" id="p8" href="#p8">8</a>[ <em>Example:</em> consider</p>

<pre><code class="sh_cpp">int x[3][5];</code></pre>

<p>Here <code class="sh_cpp">x</code> is a 3 × 5 array of integers. When <code class="sh_cpp">x</code> appears in an expression, it is converted to a
pointer to (the first of three) five-membered arrays of integers. In the expression <code class="sh_cpp">x[i]</code> which is
equivalent to <code class="sh_cpp">*(x+i)</code>, <code class="sh_cpp">x</code> is first converted to a pointer as described; then <code class="sh_cpp">x+i</code> is
converted to the type of <code class="sh_cpp">x</code>, which involves multiplying <code class="sh_cpp">i</code> by the length of the object to which
the pointer points, namely five integer objects. The results are added and indirection applied to yield an array (of
five integers), which in turn is converted to a pointer to the first of the integers. If there is another subscript the
same argument applies again; this time the result is an integer. — <em>end example</em> ]</p>
</div>
<p> — <em>end note</em> ]</p>
</div>

<p><a class="anchor" id="p9" href="#p9">9</a><span class="note">[ <em>Note:</em> It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that
the first subscript in the declaration helps determine the amount of storage consumed by an array but plays no other
part in subscript calculations. — <em>end note</em> ]</span></p>
</body>
</html>

