<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<!--[IF IE]>
	<script type="text/javascript" src="ierange.js"></script>
<![ENDIF]-->
<script type="text/javascript" src="../masha.min.js"></script>
<script type="text/javascript" src="../all_pack.js"></script>
<link rel="stylesheet" type="text/css" href="../css/masha.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<link rel="stylesheet" type="text/css" href="../styles.css">
<script type="text/javascript" src="../page.js"></script>

<title>Functions</title>
</head>
<body>
<h3>
<dfn class="label">[dcl.fct]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[dcl.fct]"></object>8.3.5 Functions </h3>

<p><a class="anchor" id="p1" href="#p1">1</a>In a declaration <code class="sh_cpp">T</code> <code class="sh_cpp">D</code> where <code class="sh_cpp">D</code> has the form</p>

<dl><dd>
<code class="sh_cpp">D1</code> <code class="sh_cpp">(</code> <i class="nonterminal">parameter-declaration-clause</i> <code class="sh_cpp">)</code>
	<i class="nonterminal">cv-qualifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">ref-qualifier</i><sub class="opt">opt</sub>
	<i class="nonterminal">exception-specification</i><sub class="opt">opt</sub> <i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub>
</dd></dl>

<p>and the type of the contained <i class="nonterminal">declarator-id</i> in the declaration <code class="sh_cpp">T D1</code> is
“<i class="nonterminal">derived-declarator-type-list</i> <code class="sh_cpp">T</code>”, the type of the <i class="nonterminal">declarator-id</i> in <code class="sh_cpp">D</code> is
“<i class="nonterminal">derived-declarator-type-list</i> function of (<i class="nonterminal">parameter-declaration-clause</i>)
<i class="nonterminal">cv-qualifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">ref-qualifier</i><sub class="opt">opt</sub> returning <code class="sh_cpp">T</code>”. The optional
<i class="nonterminal">attribute-specifier-seq</i> appertains to the function type.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>In a declaration <code class="sh_cpp">T</code> <code class="sh_cpp">D</code> where <code class="sh_cpp">D</code> has the form</p>

<dl><dd>
<code class="sh_cpp">D1</code> <code class="sh_cpp">(</code> <i class="nonterminal">parameter-declaration-clause</i> <code class="sh_cpp">)</code>
	<i class="nonterminal">cv-qualifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">ref-qualifier</i><sub class="opt">opt</sub> <i class="nonterminal">exception-specification</i><sub class="opt">opt</sub>
	<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">trailing-return-type</i>
</dd></dl>

<p>and the type of the contained <i class="nonterminal">declarator-id</i> in the declaration <code class="sh_cpp">T D1</code> is
“<i class="nonterminal">derived-declarator-type-list</i> <code class="sh_cpp">T</code>”, <code class="sh_cpp">T</code> shall be the single <i class="nonterminal">type-specifier</i>
<code class="sh_cpp">auto</code>. The type of the <i class="nonterminal">declarator-id</i> in <code class="sh_cpp">D</code> is “<i class="nonterminal">derived-declarator-type-list</i>
function of (<i class="nonterminal">parameter-declaration-clause</i>) <i class="nonterminal">cv-qualifier-seq</i><sub class="opt">opt</sub>
<i class="nonterminal">ref-qualifier</i><sub class="opt">opt</sub> returning <i class="nonterminal">trailing-return-type</i>”. The optional
<i class="nonterminal">attribute-specifier-seq</i> appertains to the function type.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>A type of either form is a <dfn>function type</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="function type"></object>.<sup class="footnote"><a href="#fn101">101</a></sup></p>
<dl>
<dt>
<dfn><i class="nonterminal">parameter-declaration-clause</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="parameter-declaration-clause"></object>:</dt>
	<dd>
<i class="nonterminal">parameter-declaration-list</i><sub class="opt">opt</sub> <code class="sh_cpp">...</code><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">parameter-declaration-list</i> <code class="sh_cpp">,</code> <code class="sh_cpp">...</code>
</dd>
<dt>
<dfn><i class="nonterminal">parameter-declaration-list</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="parameter-declaration-list"></object>:</dt>
	<dd><i class="nonterminal">parameter-declaration</i></dd>
	<dd>
<i class="nonterminal">parameter-declaration-list</i> <code class="sh_cpp">,</code> <i class="nonterminal">parameter-declaration</i>
</dd>
<dt>
<dfn><i class="nonterminal">parameter-declaration</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="parameter-declaration"></object>:</dt>
	<dd>
<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">decl-specifier-seq</i> <i class="nonterminal">declarator</i>
</dd>
	<dd>
<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">decl-specifier-seq</i> <i class="nonterminal">declarator</i> = <i class="nonterminal">initializer-clause</i>
</dd>
	<dd>
<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">decl-specifier-seq</i> <i class="nonterminal">abstract-declarator</i><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">attribute-specifier-seq</i><sub class="opt">opt</sub> <i class="nonterminal">decl-specifier-seq</i> <i class="nonterminal">abstract-declarator</i><sub class="opt">opt</sub> <code class="sh_cpp">=</code> <i class="nonterminal">initializer-clause</i>
</dd>
</dl>
<p>The optional <i class="nonterminal">attribute-specifier-seq</i> in a <i class="nonterminal">parameter-declaration</i> appertains to the parameter.</p>

<p><a class="anchor" id="p4" href="#p4">4</a>The <i class="nonterminal">parameter-declaration-clause</i> determines the arguments that can be specified, and their processing,
when the function is called. <span class="note">[ <em>Note:</em> the <i class="nonterminal">parameter-declaration-clause</i> is used to convert the arguments specified
on the function call; see <a title="expr.call" href="expr.call.html">5.2.2</a>. — <em>end note</em> ]</span> If the <i class="nonterminal">parameter-declaration-clause</i> is empty, the function
takes no arguments. The parameter list <code class="sh_cpp">(void)</code> is equivalent to the empty parameter list. Except for this
special case, <code class="sh_cpp">void</code> shall not be a parameter type (though types derived from <code class="sh_cpp">void</code>, such as
<code class="sh_cpp">void*</code>, can). If the <i class="nonterminal">parameter-declaration-clause</i> terminates with an ellipsis or a function
parameter pack (<a title="temp.variadic" href="temp.variadic.html">14.5.3</a>), the number of arguments shall be equal to or greater than the number of parameters
that do not have a default argument and are not function parameter packs. Where syntactically correct and where
“<code class="sh_cpp">...</code>” is not part of an <i class="nonterminal">abstract-declarator</i>, “<code class="sh_cpp">,</code> <code class="sh_cpp">...</code>” is synonymous with
“<code class="sh_cpp">...</code>”.</p>

<div class="example">
<p>[ <em>Example:</em> the declaration</p>

<pre><code class="sh_cpp">int printf(const char*, ...);</code></pre>

<p>declares a function that can be called with varying numbers and types of arguments.</p>

<pre><code class="sh_cpp">printf("hello world");
printf("a=%d b=%d", a, b);</code></pre>

<p>However, the first argument must be of a type that can be converted to a <code class="sh_cpp">const char*</code>. — <em>end example</em> ]</p>
</div>

<p><span class="note">[ <em>Note:</em> The standard header <code class="header">&lt;cstdarg&gt;</code> contains a mechanism for accessing arguments passed using the
ellipsis (see <a title="expr.call" href="expr.call.html">5.2.2</a> and <a title="support.runtime" href="support.runtime.html">18.10</a>). — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p5" href="#p5">5</a>A single name can be used for several different functions in a single scope; this is function overloading
(Clause <a title="over" href="over.html">13</a>). All declarations for a function shall agree exactly in both the return type and the
parameter-type-list. The type of a function is determined using the following rules. The type of each parameter
(including function parameter packs) is determined from its own <i class="nonterminal">decl-specifier-seq</i> and <i class="nonterminal">declarator</i>.
After determining the type of each parameter, any parameter of type “array of <code class="sh_cpp">T</code>” or “function returning
<code class="sh_cpp">T</code>” is adjusted to be “pointer to <code class="sh_cpp">T</code>” or “pointer to function returning <code class="sh_cpp">T</code>”,
respectively. After producing the list of parameter types, any top-level <i class="nonterminal">cv-qualifier</i>s modifying a parameter
type are deleted when forming the function type. The resulting list of transformed parameter types and the presence or
absence of the ellipsis or a function parameter pack is the function’s <i class="nonterminal">parameter-type-list</i>. <span class="note">[ <em>Note:</em> This
transformation does not affect the types of the parameters. For example, <code class="sh_cpp">int(*)(const int p, decltype(p)*)</code>
and <code class="sh_cpp">int(*)(int, const int*)</code> are identical types. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p6" href="#p6">6</a>A <i class="nonterminal">cv-qualifier-seq</i> or a <i class="nonterminal">ref-qualifier</i> shall only be part of:</p>

<ul>
<li>the function type for a non-static member function,</li>
<li>the function type to which a pointer to member refers,</li>
<li>the top-level function type of a function typedef declaration or <i class="nonterminal">alias-declaration</i>,</li>
<li>the <i class="nonterminal">type-id</i> in the default argument of a <i class="nonterminal">type-parameter</i> (<a title="temp.param" href="temp.param.html">14.1</a>), or</li>
<li>the <i class="nonterminal">type-id</i> of a <i class="nonterminal">template-argument</i> for a <i class="nonterminal">type-parameter</i> (<a title="temp.names" href="temp.names.html">14.2</a>).</li>
</ul>

<p>The effect of a <i class="nonterminal">cv-qualifier-seq</i> in a function declarator is not the same as adding cv-qualification on top
of the function type. In the latter case, the cv-qualifiers are ignored. <span class="note">[ <em>Note:</em> A function type that has a
<i class="nonterminal">cv-qualifier-seq</i> is not a cv-qualified type; there are no cv-qualified function types. — <em>end note</em> ]</span></p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">typedef void F();
struct S {
  const F f;            // OK: equivalent to: void f();
};</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p>The return type, the parameter-type-list, the <i class="nonterminal">ref-qualifier</i>, and the <i class="nonterminal">cv-qualifier-seq</i>, but not the
default arguments (<a title="dcl.fct.default" href="dcl.fct.default.html">8.3.6</a>) or the exception specification (<a title="except.spec" href="except.spec.html">15.4</a>), are part of the function type.
<span class="note">[ <em>Note:</em> Function types are checked during the assignments and initializations of pointers to functions, references to
functions, and pointers to member functions. — <em>end note</em> ]</span></p>

<div class="example">
<p><a class="anchor" id="p7" href="#p7">7</a>[ <em>Example:</em> the declaration</p>

<pre><code class="sh_cpp">int fseek(FILE*, long, int);</code></pre>

<p>declares a function taking three arguments of the specified types, and returning int (<a title="dcl.type" href="dcl.type.html">7.1.6</a>). — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p8" href="#p8">8</a>If the type of a parameter includes a type of the form “pointer to array of unknown bound of <code class="sh_cpp">T</code>” or
“reference to array of unknown bound of <code class="sh_cpp">T</code>”, the program is ill-formed.<sup class="footnote"><a href="#fn102">102</a></sup> Functions shall not
have a return type of type array or function, although they may have a return type of type pointer or reference to such
things. There shall be no arrays of functions, although there can be arrays of pointers to functions.</p>

<p><a class="anchor" id="p9" href="#p9">9</a>Types shall not be defined in return or parameter types. The type of a parameter or the return type for a
function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is
nested within the <i class="nonterminal">member-specification</i> for that class (including definitions in nested classes defined within
the class).</p>

<p><a class="anchor" id="p10" href="#p10">10</a>A typedef of function type may be used to declare a function but shall not be used to define a function
(<a title="dcl.fct.def" href="dcl.fct.def.general.html">8.4</a>).</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">typedef void F();
F fv;                   // OK: equivalent to void fv();
F fv { }                // ill-formed
void fv() { }           // OK: definition of fv</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p>A typedef of a function type whose declarator includes a <i class="nonterminal">cv-qualifier-seq</i> shall be used only to declare the
function type for a non-static member function, to declare the function type to which a pointer to member refers, or to
declare the top-level function type of another function typedef declaration.</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">typedef int FIC(int) const;
FIC f;                  // ill-formed: does not declare a member function
struct S {
  FIC f;                // OK
};
FIC S::*pm = &amp;S::f;     // OK</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p11" href="#p11">11</a>An identifier can optionally be provided as a parameter name; if present in a function definition
(<a title="dcl.fct.def" href="dcl.fct.def.general.html">8.4</a>), it names a parameter (sometimes called “formal argument”). <span class="note">[ <em>Note:</em> In particular, parameter names are
also optional in function definitions and names used for a parameter in different declarations and the definition of a
function need not be the same. If a parameter name is present in a function declaration that is not a definition, it
cannot be used outside of its function declarator because that is the extent of its potential scope
(<a title="basic.scope.proto" href="basic.scope.proto.html">3.3.4</a>). — <em>end note</em> ]</span></p>

<div class="example">
<p><a class="anchor" id="p12" href="#p12">12</a>[ <em>Example:</em> the declaration</p>

<pre><code class="sh_cpp">int i,
    *pi,
    f(),
    *fpi(int),
    (*pif)(const char*, const char*),
    (*fpif(int))(int);</code></pre>

<p>declares an integer <code class="sh_cpp">i</code>, a pointer <code class="sh_cpp">pi</code> to an integer, a function <code class="sh_cpp">f</code> taking no
arguments and returning an integer, a function <code class="sh_cpp">fpi</code> taking an integer argument and returning a pointer to an
integer, a pointer <code class="sh_cpp">pif</code> to a function which takes two pointers to constant characters and returns an
integer, a function <code class="sh_cpp">fpif</code> taking an integer argument and returning a pointer to a function that takes an
integer argument and returns an integer. It is especially useful to compare <code class="sh_cpp">fpi</code> and <code class="sh_cpp">pif</code>. The
binding of <code class="sh_cpp">*fpi(int)</code> is <code class="sh_cpp">*(fpi(int))</code>, so the declaration suggests, and the same construction in
an expression requires, the calling of a function <code class="sh_cpp">fpi</code>, and then using indirection through the (pointer)
result to yield an integer. In the declarator <code class="sh_cpp">(*pif)(const char*, const char*)</code>, the extra parentheses are
necessary to indicate that indirection through a pointer to a function yields a function, which is then
called. — <em>end example</em> ]</p>
</div>

<div class="note">
<p>[ <em>Note:</em> Typedefs and <i class="nonterminal">trailing-return-type</i>s are sometimes convenient when the return type of a function is complex. For
example, the function <code class="sh_cpp">fpif</code> above could have been declared</p>

<pre><code class="sh_cpp">typedef int IFUNC(int);
IFUNC* fpif(int);</code></pre>

<p>or</p>

<pre><code class="sh_cpp">auto fpif(int)-&gt;int(*)(int)</code></pre>

<p>A <i class="nonterminal">trailing-return-type</i> is most useful for a type that would be more complicated to specify before the
<i class="nonterminal">declarator-id</i>:</p>

<pre><code class="sh_cpp">template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</code></pre>

<p>rather than</p>

<pre><code class="sh_cpp">template &lt;class T, class U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);</code></pre>
<p> — <em>end note</em> ]</p>
</div>

<p><a class="anchor" id="p13" href="#p13">13</a>A <i class="nonterminal">declarator-id</i> or <i class="nonterminal">abstract-declarator</i> containing an ellipsis shall only be used in a
<i class="nonterminal">parameter-declaration</i>. Such a <i class="nonterminal">parameter-declaration</i> is a parameter pack (<a title="temp.variadic" href="temp.variadic.html">14.5.3</a>). When it
is part of a <i class="nonterminal">parameter-declaration-clause</i>, the parameter pack is a function parameter pack (<a title="temp.variadic" href="temp.variadic.html">14.5.3</a>).
<span class="note">[ <em>Note:</em> Otherwise, the <i class="nonterminal">parameter-declaration</i> is part of a <i class="nonterminal">template-parameter-list</i> and the parameter pack
is a template parameter pack; see <a title="temp.param" href="temp.param.html">14.1</a>. — <em>end note</em> ]</span> A function parameter pack is a pack expansion
(<a title="temp.variadic" href="temp.variadic.html">14.5.3</a>).</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">template&lt;typename... T&gt; void f(T (* ...t)(int, int));

int add(int, int);
float subtract(int, int);

void g() {
  f(add, subtract);
}</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p14" href="#p14">14</a>There is a syntactic ambiguity when an ellipsis occurs at the end of a <i class="nonterminal">parameter-declaration-clause</i>
without a preceding comma. In this case, the ellipsis is parsed as part of the <i class="nonterminal">abstract-declarator</i> if the type
of the parameter names a template parameter pack that has not been expanded; otherwise, it is parsed as part of the
<i class="nonterminal">parameter-declaration-clause</i>.<sup class="footnote"><a href="#fn103">103</a></sup></p>






<div>
<p class="footnote" id="fn101">101) As indicated by syntax, cv-qualifiers are a signficant component in function return types.</p>
<p class="footnote" id="fn102">102) This excludes parameters of type “<i class="nonterminal">ptr-arr-seq</i> <code class="sh_cpp">T2</code>” where <code class="sh_cpp">T2</code> is
“pointer to array of unknown bound of <code class="sh_cpp">T</code>” and where <i class="nonterminal">ptr-arr-seq</i> means any sequence of “pointer to”
and “array of” derived declarator types. This exclusion applies to the parameters of the function, and if a parameter is
a pointer to function or pointer to member function then to its parameters also, etc.</p>
<p class="footnote" id="fn103">103) One can explicitly disambiguate the parse either by introducing a comma (so the ellipsis will be
parsed as part of the <i class="nonterminal">parameter-declaration-clause</i>) or by introducing a name for the parameter (so the ellipsis
will be parsed as part of the <i class="nonterminal">declarator-id</i>).</p>
</div>
</body>
</html>



