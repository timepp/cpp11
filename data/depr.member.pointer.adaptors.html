<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Adaptors for pointers to members</title>
</head>
<body>
<h4>
<dfn class="label">[depr.member.pointer.adaptors]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[depr.member.pointer.adaptors]"></object>D.8.2.2 Adaptors for pointers to members </h4>

<p><a class="anchor" id="p1" href="#p1">1</a>The purpose of the following is to provide the same facilities for pointer to members as those provided for
pointers to functions in <a title="depr.function.pointer.adaptors" href="depr.function.pointer.adaptors.html">D.8.2.1</a>.</p>

<h5><code class="sh_cpp">template &lt;class S, class T&gt; class <dfn>mem_fun_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_t"></object>
  : public unary_function&lt;T*, S&gt; {
public:
  explicit mem_fun_t(S (T::*p)());
  S operator()(T* p) const;
};</code></h5>

<p><a class="anchor" id="p2" href="#p2">2</a><code class="sh_cpp">mem_fun_t</code> calls the member function it is initialized with given a pointer argument.</p>

<h5><code class="sh_cpp">template &lt;class S, class T, class A&gt; class <dfn>mem_fun1_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun1_t"></object>
  : public binary_function&lt;T*, A, S&gt; {
public:
  explicit mem_fun1_t(S (T::*p)(A));
  S operator()(T* p, A x) const;
};</code></h5>

<p><a class="anchor" id="p3" href="#p3">3</a><code class="sh_cpp">mem_fun1_t</code> calls the member function it is initialized with given a pointer argument and an
additional argument of the appropriate type.</p>

<h5><code class="sh_cpp">template&lt;class S, class T&gt; mem_fun_t&lt;S,T&gt;
  <dfn>mem_fun</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun"></object>(S (T::*f)());
template&lt;class S, class T, class A&gt; mem_fun1_t&lt;S,T,A&gt;
  <dfn>mem_fun</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun"></object>(S (T::*f)(A));</code></h5>

<p><a class="anchor" id="p4" href="#p4">4</a><code class="sh_cpp">mem_fun(&amp;X::f)</code> returns an object through which <code class="sh_cpp">X::f</code> can be called given a pointer
to an <code class="sh_cpp">X</code> followed by the argument required for <code class="sh_cpp">f</code> (if any).</p>

<h5><code class="sh_cpp">template &lt;class S, class T&gt; class <dfn>mem_fun_ref_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_ref_t"></object>
  : public unary_function&lt;T, S&gt; {
public:
  explicit mem_fun_ref_t(S (T::*p)());
  S operator()(T&amp; p) const;
};</code></h5>

<p><a class="anchor" id="p5" href="#p5">5</a><code class="sh_cpp">mem_fun_ref_t</code> calls the member function it is initialized with given a reference argument.</p>

<h5><code class="sh_cpp">template &lt;class S, class T, class A&gt; class <dfn>mem_fun1_ref_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun1_ref_t"></object>
  : public binary_function&lt;T, A, S&gt; {
public:
  explicit mem_fun1_ref_t(S (T::*p)(A));
  S operator()(T&amp; p, A x) const;
};</code></h5>

<p><a class="anchor" id="p6" href="#p6">6</a><code class="sh_cpp">mem_fun1_ref_t</code> calls the member function it is initialized with given a reference argument and an
additional argument of the appropriate type.</p>

<h5><code class="sh_cpp">template&lt;class S, class T&gt; mem_fun_ref_t&lt;S,T&gt;
  <dfn>mem_fun_ref</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_ref"></object>(S (T::*f)());
template&lt;class S, class T, class A&gt; mem_fun1_ref_t&lt;S,T,A&gt;
  <dfn>mem_fun_ref</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_ref"></object>(S (T::*f)(A));</code></h5>

<p><a class="anchor" id="p7" href="#p7">7</a><code class="sh_cpp">mem_fun_ref(&amp;X::f)</code> returns an object through which <code class="sh_cpp">X::f</code> can be called given a
reference to an <code class="sh_cpp">X</code> followed by the argument required for <code class="sh_cpp">f</code> (if any).</p>

<h5><code class="sh_cpp">template &lt;class S, class T&gt; class <dfn>const_mem_fun_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="const_mem_fun_t"></object>
  : public unary_function&lt;const T*, S&gt; {
public:
  explicit const_mem_fun_t(S (T::*p)() const);
  S operator()(const T* p) const;
};</code></h5>

<p><a class="anchor" id="p8" href="#p8">8</a><code class="sh_cpp">const_mem_fun_t</code> calls the member function it is initialized with given a pointer argument.</p>

<h5><code class="sh_cpp">template &lt;class S, class T, class A&gt; class <dfn>const_mem_fun1_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="const_mem_fun1_t"></object>
  : public binary_function&lt;const T*, A, S&gt; {
public:
  explicit const_mem_fun1_t(S (T::*p)(A) const);
  S operator()(const T* p, A x) const;
};</code></h5>

<p><a class="anchor" id="p9" href="#p9">9</a><code class="sh_cpp">const_mem_fun1_t</code> calls the member function it is initialized with given a pointer argument and an
additional argument of the appropriate type.</p>

<h5><code class="sh_cpp">template&lt;class S, class T&gt; const_mem_fun_t&lt;S,T&gt;
  <dfn>mem_fun</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun"></object>(S (T::*f)() const);
template&lt;class S, class T, class A&gt; const_mem_fun1_t&lt;S,T,A&gt;
  <dfn>mem_fun</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun"></object>(S (T::*f)(A) const);</code></h5>

<p><a class="anchor" id="p10" href="#p10">10</a><code class="sh_cpp">mem_fun(&amp;X::f)</code> returns an object through which <code class="sh_cpp">X::f</code> can be called given a
pointer to an <code class="sh_cpp">X</code> followed by the argument required for <code class="sh_cpp">f</code> (if any).</p>

<h5><code class="sh_cpp">template &lt;class S, class T&gt; class <dfn>const_mem_fun_ref_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="const_mem_fun_ref_t"></object>
  : public unary_function&lt;T, S&gt; {
public:
  explicit const_mem_fun_ref_t(S (T::*p)() const);
  S operator()(const T&amp; p) const;
};</code></h5>

<p><a class="anchor" id="p11" href="#p11">11</a><code class="sh_cpp">const_mem_fun_ref_t</code> calls the member function it is initialized with given a reference
argument.</p>

<h5><code class="sh_cpp">template &lt;class S, class T, class A&gt; class <dfn>const_mem_fun1_ref_t</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="const_mem_fun1_ref_t"></object>
  : public binary_function&lt;T, A, S&gt; {
public:
   explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
   S operator()(const T&amp; p, A x) const;
};</code></h5>

<p><a class="anchor" id="p12" href="#p12">12</a><code class="sh_cpp">const_mem_fun1_ref_t</code> calls the member function it is initialized with given a reference argument
and an additional argument of the appropriate type.</p>

<h5><code class="sh_cpp">template&lt;class S, class T&gt; const_mem_fun_ref_t&lt;S,T&gt;
  <dfn>mem_fun_ref</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_ref"></object>(S (T::*f)() const);
template&lt;class S, class T, class A&gt; const_mem_fun1_ref_t&lt;S,T,A&gt;
  <dfn>mem_fun_ref</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="mem_fun_ref"></object>(S (T::*f)(A) const);</code></h5>

<p><a class="anchor" id="p13" href="#p13">13</a><code class="sh_cpp">mem_fun_ref(&amp;X::f)</code> returns an object through which <code class="sh_cpp">X::f</code> can be called given a
reference to an <code class="sh_cpp">X</code> followed by the argument required for <code class="sh_cpp">f</code> (if any).</p>
</body>
</html>

