<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<!--[IF IE]>
	<script type="text/javascript" src="ierange.js"></script>
<![ENDIF]-->
<script type="text/javascript" src="../masha.min.js"></script>
<script type="text/javascript" src="../all_pack.js"></script>
<link rel="stylesheet" type="text/css" href="../css/masha.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<link rel="stylesheet" type="text/css" href="../styles.css">
<script type="text/javascript" src="../page.js"></script>

<title>String literals</title>
</head>
<body>
<h3>
<dfn class="label">[lex.string]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[lex.string]"></object>2.14.5 String literals </h3>
<dl>
<dt>
<i class="nonterminal"><dfn>string-literal</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="string-literal"></object></i>:</dt>
	<dd>
<i class="nonterminal">encoding-prefix</i><sub class="opt">opt</sub> <code class="sh_cpp">"</code> <i class="nonterminal">s-char-sequence</i><sub class="opt">opt</sub> <code class="sh_cpp">"</code>
</dd>
	<dd>
<i class="nonterminal">encoding-prefix</i><sub class="opt">opt</sub> <code class="sh_cpp">R</code> <i class="nonterminal">raw-string</i>
</dd>
<dt>
<i class="nonterminal"><dfn>encoding-prefix</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="encoding-prefix"></object></i>:</dt>
	<dd><code class="sh_cpp">u8</code></dd>
	<dd><code class="sh_cpp">u</code></dd>
	<dd><code class="sh_cpp">U</code></dd>
	<dd><code class="sh_cpp">L</code></dd>
<dt>
<i class="nonterminal"><dfn>s-char-sequence</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="s-char-sequence"></object></i>:</dt>
	<dd><i class="nonterminal">s-char</i></dd>
	<dd>
<i class="nonterminal">s-char-sequence</i> <i class="nonterminal">s-char</i>
</dd>
<dt>
<i class="nonterminal"><dfn>s-char</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="s-char"></object></i>:</dt>
	<dd>any member of the source character set except the double-quote <code class="sh_cpp">"</code>, backslash <code class="sh_cpp">\</code>, or new-line
		character</dd>
	<dd><i class="nonterminal">escape-sequence</i></dd>
	<dd><i class="nonterminal">universal-character-name</i></dd>
<dt>
<i class="nonterminal"><dfn>raw-string</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="raw-string"></object></i>:</dt>
	<dd>
<code class="sh_cpp">"</code> <i class="nonterminal">d-char-sequence</i><sub class="opt">opt</sub> <code class="sh_cpp">(</code> <i class="nonterminal">r-char-sequence</i><sub class="opt">opt</sub> <code class="sh_cpp">)</code> <i class="nonterminal">d-char-sequence</i><sub class="opt">opt</sub> <code class="sh_cpp">"</code>
</dd>
<dt>
<i class="nonterminal"><dfn>r-char-sequence</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="r-char-sequence"></object></i>:</dt>
	<dd><i class="nonterminal">r-char</i></dd>
	<dd>
<i class="nonterminal">r-char-sequence</i> <i class="nonterminal">r-char</i>
</dd>
<dt>
<i class="nonterminal"><dfn>r-char</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="r-char"></object></i>:</dt>
	<dd>any member of the source character set, except a right parenthesis <code class="sh_cpp">)</code> followed by the initial
		<i class="nonterminal">d-char-sequence</i> (which may be empty) followed by a double quote <code class="sh_cpp">"</code>.</dd>
<dt>
<i class="nonterminal"><dfn>d-char-sequence</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="d-char-sequence"></object></i>:</dt>
	<dd><i class="nonterminal">d-char</i></dd>
	<dd>
<i class="nonterminal">d-char-sequence</i> <i class="nonterminal">d-char</i>
</dd>
<dt>
<i class="nonterminal"><dfn>d-char</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="d-char"></object></i>:</dt>
	<dd>any member of the basic source character set except: space, the left parenthesis <code class="sh_cpp">(</code>, the right
		parenthesis <code class="sh_cpp">)</code>, the backslash <code class="sh_cpp">\</code>, and the control characters representing horizontal
		tab, vertical tab, form feed, and newline.</dd>
</dl>

<p><a class="anchor" id="p1" href="#p1">1</a>A string literal is a sequence of characters (as defined in <code class="sh_cpp">2.14.3</code>) surrounded by double quotes,
optionally prefixed by <code class="sh_cpp">R</code>, <code class="sh_cpp">u8</code>, <code class="sh_cpp">u8R</code>, <code class="sh_cpp">u</code>, <code class="sh_cpp">uR</code>,
<code class="sh_cpp">U</code>, <code class="sh_cpp">UR</code>, <code class="sh_cpp">L</code>, or <code class="sh_cpp">LR</code>, as in <code class="sh_cpp">"..."</code>, <code class="sh_cpp">R"(...)"</code>,
<code class="sh_cpp">u8"..."</code>, <code class="sh_cpp">u8R"**(...)**"</code>, <code class="sh_cpp">u"..."</code>, <code class="sh_cpp">uR"*~(...)*~"</code>, <code class="sh_cpp">U"..."</code>,
<code class="sh_cpp">UR"zzz(...)zzz"</code>, <code class="sh_cpp">L"..."</code>, or <code class="sh_cpp">LR"(...)"</code>, respectively.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>A string literal that has an <code class="sh_cpp">R</code> in the prefix is a <dfn>raw string literal</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="raw string literal"></object>. The
<i class="nonterminal">d-char-sequence</i> serves as a delimiter. The terminating <i class="nonterminal">d-char-sequence</i> of a raw-string is the same
sequence of characters as the initial <i class="nonterminal">d-char-sequence</i>. A <i class="nonterminal">d-char-sequence</i> shall consist of at most 16
characters.</p>

<p><a class="anchor" id="p3" href="#p3">3</a><span class="note">[ <em>Note:</em> The characters <code class="sh_cpp">'('</code> and <code class="sh_cpp">')'</code> are permitted in a <i class="nonterminal">raw-string</i>. Thus,
<code class="sh_cpp">R"delimiter((a|b))delimiter"</code> is equivalent to <code class="sh_cpp">"(a|b)"</code>. — <em>end note</em> ]</span></p>

<div class="note">
<p><a class="anchor" id="p4" href="#p4">4</a>[ <em>Note:</em> A source-file new-line in a raw string literal results in a new-line in the resulting execution
<i class="nonterminal">string-literal</i>. Assuming no whitespace at the beginning of lines in the following example, the assert will
succeed:</p>

<pre><code class="sh_cpp">const char *p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);</code></pre>

<p> — <em>end note</em> ]</p>
</div>

<div class="example">
<p><a class="anchor" id="p5" href="#p5">5</a>[ <em>Example:</em> The raw string</p>

<pre><code class="sh_cpp">R"a(
)\
a"
)a"</code></pre>

<p>is equivalent to <code class="sh_cpp">"\n)\\\na\"\n"</code>. The raw string</p>

<pre><code class="sh_cpp">R"(??)"</code></pre>

<p>is equivalent to <code class="sh_cpp">"\?\?"</code>. The raw string</p>

<pre><code class="sh_cpp">R"#(
)??="
)#"</code></pre>

<p>is equivalent to <code class="sh_cpp">"\n)\?\?=\"\n"</code>. — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p6" href="#p6">6</a>After translation phase 6, a string literal that does not begin with an <i class="nonterminal">encoding-prefix</i> is an ordinary
string literal, and is initialized with the given characters.</p>

<p><a class="anchor" id="p7" href="#p7">7</a>A string literal that begins with <code class="sh_cpp">u8</code>, such as <code class="sh_cpp">u8"asdf"</code>, is a UTF-8 string literal and
is initialized with the given characters as encoded in UTF-8.</p>

<p><a class="anchor" id="p8" href="#p8">8</a>Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow
string literal has type “array of <var>n</var> <code class="sh_cpp">const char</code>”, where <var>n</var> is the size of the string as
defined below, and has static storage duration (<a title="basic.stc" href="basic.stc.html">3.7</a>).</p>

<p><a class="anchor" id="p9" href="#p9">9</a>A string literal that begins with <code class="sh_cpp">u</code>, such as <code class="sh_cpp">u"asdf"</code>, is a <code class="sh_cpp">char16_t</code>
string literal. A <code class="sh_cpp">char16_t</code> string literal has type “array of <var>n</var> <code class="sh_cpp">const char16_t</code>”,
where <var>n</var> is the size of the string as defined below; it has static storage duration and is initialized with
the given characters. A single <i class="nonterminal">c-char</i> may produce more than one <code class="sh_cpp">char16_t</code> character in the form of
surrogate pairs.</p>

<p><a class="anchor" id="p10" href="#p10">10</a>A string literal that begins with <code class="sh_cpp">U</code>, such as <code class="sh_cpp">U"asdf"</code>, is a <code class="sh_cpp">char32_t</code>
string literal. A <code class="sh_cpp">char32_t</code> string literal has type “array of <var>n</var> <code class="sh_cpp">const char32_t</code>”,
where <var>n</var> is the size of the string as defined below; it has static storage duration and is initialized with
the given characters.</p>

<p><a class="anchor" id="p11" href="#p11">11</a>A string literal that begins with <code class="sh_cpp">L</code>, such as <code class="sh_cpp">L"asdf"</code>, is a wide string literal. A
wide string literal has type “array of <var>n</var> <code class="sh_cpp">const wchar_t</code>”, where <var>n</var> is the size of the
string as defined below; it has static storage duration and is initialized with the given characters.</p>

<p><a class="anchor" id="p12" href="#p12">12</a>Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is
implementation-defined. The effect of attempting to modify a string literal is undefined.</p>

<p><a class="anchor" id="p13" href="#p13">13</a>In translation phase 6 (<a title="lex.phases" href="lex.phases.html">2.2</a>), adjacent string literals are concatenated. If both string literals
have the same <i class="nonterminal">encoding-prefix</i>, the resulting concatenated string literal has that <i class="nonterminal">encoding-prefix</i>. If
one string literal has no <i class="nonterminal">encoding-prefix</i>, it is treated as a string literal of the same
<i class="nonterminal">encoding-prefix</i> as the other operand. If a UTF-8 string literal token is adjacent to a wide string literal
token, the program is ill-formed. Any other concatenations are conditionally supported with implementation-defined
behavior. <span class="note">[ <em>Note:</em> This concatenation is an interpretation, not a conversion. Because the interpretation happens in
translation phase 6 (after each character from a literal has been translated into a value from the appropriate character
set), a string literal’s initial rawness has no effect on the interpretation or well-formedness of the
concatenation. — <em>end note</em> ]</span> Table <a href="lex.string.html#t8">8</a> has some examples of valid concatenations.</p>

<table id="t8" class="bordered headed pair-ruled padded">
<caption>Table 8 — String literal concatenations</caption>
<thead><tr>
<th>Source</th>
<th>Means</th>
<th>Source</th>
<th>Means</th>
<th>Source</th>
<th>Means</th>
</tr></thead>
<tbody>
<tr>
<td><code class="sh_cpp">u"a" u"b"</code></td>
<td><code class="sh_cpp">u"ab"</code></td>
	<td><code class="sh_cpp">U"a" U"b"</code></td>
<td><code class="sh_cpp">U"ab"</code></td>
	<td><code class="sh_cpp">L"a" L"b"</code></td>
<td><code class="sh_cpp">L"ab"</code></td>
</tr>
<tr>
<td><code class="sh_cpp">u"a" "b"</code></td>
<td><code class="sh_cpp">u"ab"</code></td>
	<td><code class="sh_cpp">U"a" "b"</code></td>
<td><code class="sh_cpp">U"ab"</code></td>
	<td><code class="sh_cpp">L"a" "b"</code></td>
<td><code class="sh_cpp">L"ab"</code></td>
</tr>
<tr>
<td><code class="sh_cpp">"a" u"b"</code></td>
<td><code class="sh_cpp">u"ab"</code></td>
	<td><code class="sh_cpp">"a" U"b"</code></td>
<td><code class="sh_cpp">U"ab"</code></td>
	<td><code class="sh_cpp">"a" L"b"</code></td>
<td><code class="sh_cpp">L"ab"</code></td>
</tr>
</tbody>
</table>

<p>Characters in concatenated strings are kept distinct.</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">"\xA" "B"</code></pre>

<p>contains the two characters <code class="sh_cpp">'\xA'</code> and <code class="sh_cpp">'B'</code> after concatenation (and not the single
hexadecimal character <code class="sh_cpp">'\xAB'</code>). — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p14" href="#p14">14</a>After any necessary concatenation, in translation phase 7 (<a title="lex.phases" href="lex.phases.html">2.2</a>), <code class="sh_cpp">'\0'</code> is appended to
every string literal so that programs that scan a string can find its end.</p>

<p><a class="anchor" id="p15" href="#p15">15</a>Escape sequences and universal-character-names in non-raw string literals have the same
meaning as in character literals (<a title="lex.ccon" href="lex.ccon.html">2.14.3</a>), except that the single quote <code class="sh_cpp">'</code> is representable
either by itself or by the escape sequence <code class="sh_cpp">\'</code>, and the double quote <code class="sh_cpp">"</code> shall be preceded by a
<code class="sh_cpp">\</code>. In a narrow string literal, a universal-character-name may map to more than one char element due to
<dfn>multibyte encoding</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="multibyte encoding"></object>. The size of a <code class="sh_cpp">char32_t</code> or wide string literal is the total number of escape
sequences, universal-character-names, and other characters, plus one for the terminating <code class="sh_cpp">U'\0'</code> or
<code class="sh_cpp">L'\0'</code>. The size of a <code class="sh_cpp">char16_t</code> string literal is the total number of escape sequences,
universal-character-names, and other characters, plus one for each character requiring a surrogate pair, plus one for
the terminating <code class="sh_cpp">u'\0'</code>. <span class="note">[ <em>Note:</em> The size of a <code class="sh_cpp">char16_t</code> string literal is the number of code
units, not the number of characters. — <em>end note</em> ]</span> Within <code class="sh_cpp">char32_t</code> and <code class="sh_cpp">char16_t</code> literals, any
universal-character-names shall be within the range <code class="sh_cpp">0x0</code> to <code class="sh_cpp">0x10FFFF</code>. The size of a narrow
string literal is the total number of escape sequences and other characters, plus at least one for the multibyte
encoding of each universal-character-name, plus one for the terminating <code class="sh_cpp">'\0'</code>.</p>
</body>
</html>



