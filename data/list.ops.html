<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>list operations</title>
</head>
<body>
<h4>
<dfn class="label">[list.ops]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[list.ops]"></object>23.3.5.5 <code class="sh_cpp">list</code> operations </h4>

<p><a class="anchor" id="p1" href="#p1">1</a>Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided
specifically for them.<sup class="footnote"><a href="#fn268">268</a></sup></p>

<p><a class="anchor" id="p2" href="#p2">2</a><code class="sh_cpp">list</code> provides three splice operations that destructively move elements from one list to another.
The behavior of splice operations is undefined if <code class="sh_cpp">get_allocator() != x.get_allocator()</code>.</p>

<h5><code class="sh_cpp">void <dfn>splice</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="splice"></object>(const_iterator position, list&lt;T, Allocator&gt;&amp; x);
void splice(const_iterator position, list&lt;T, Allocator&gt;&amp;&amp; x);</code></h5>

<p><a class="anchor" id="p3" href="#p3">3</a><em>Requires:</em> <code class="sh_cpp">&amp;x != this</code>.</p>

<p><a class="anchor" id="p4" href="#p4">4</a><em>Effects:</em> Inserts the contents of <code class="sh_cpp">x</code> before <code class="sh_cpp">position</code> and <code class="sh_cpp">x</code> becomes empty.
Pointers and references to the moved elements of <code class="sh_cpp">x</code> now refer to those same elements but as members of
<code class="sh_cpp">*this</code>. Iterators referring to the moved elements will continue to refer to their elements, but they now
behave as iterators into <code class="sh_cpp">*this</code>, not into <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p5" href="#p5">5</a><em>Throws:</em> Nothing.</p>

<p><a class="anchor" id="p6" href="#p6">6</a><em>Complexity:</em> Constant time.</p>

<h5><code class="sh_cpp">void <dfn>splice</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="splice"></object>(const_iterator position, list&lt;T, Allocator&gt;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T, Allocator&gt;&amp;&amp; x, const_iterator i);</code></h5>

<p><a class="anchor" id="p7" href="#p7">7</a><em>Effects:</em> Inserts an element pointed to by <code class="sh_cpp">i</code> from list <code class="sh_cpp">x</code> before <code class="sh_cpp">position</code>
and removes the element from <code class="sh_cpp">x</code>. The result is unchanged if <code class="sh_cpp">position == i</code> or <code class="sh_cpp">position ==
++i</code>. Pointers and references to <code class="sh_cpp">*i</code> continue to refer to this same element but as a member of
<code class="sh_cpp">*this</code>. Iterators to <code class="sh_cpp">*i</code> (including <code class="sh_cpp">i</code> itself) continue to refer to the same
element, but now behave as iterators into <code class="sh_cpp">*this</code>, not into <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p8" href="#p8">8</a><em>Requires:</em> <code class="sh_cpp">i</code> is a valid dereferenceable iterator of <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p9" href="#p9">9</a><em>Throws:</em> Nothing.</p>

<p><a class="anchor" id="p10" href="#p10">10</a><em>Complexity:</em> Constant time.</p>

<h5><code class="sh_cpp">void <dfn>splice</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="splice"></object>(const_iterator position, list&lt;T, Allocator&gt;&amp; x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&lt;T, Allocator&gt;&amp;&amp; x, const_iterator first,
            const_iterator last);</code></h5>

<p><a class="anchor" id="p11" href="#p11">11</a><em>Effects:</em> Inserts elements in the range <code class="sh_cpp">[first, last)</code> before <code class="sh_cpp">position</code> and removes the
elements from <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p12" href="#p12">12</a><em>Requires:</em> <code class="sh_cpp">[first, last)</code> is a valid range in <code class="sh_cpp">x</code>. The result is undefined if
<code class="sh_cpp">position</code> is an iterator in the range <code class="sh_cpp">[first, last)</code>. Pointers and references to the moved
elements of <code class="sh_cpp">x</code> now refer to those same elements but as members of <code class="sh_cpp">*this</code>. Iterators referring to
the moved elements will continue to refer to their elements, but they now behave as iterators into <code class="sh_cpp">*this</code>,
not into <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p13" href="#p13">13</a><em>Throws:</em> Nothing.</p>

<p><a class="anchor" id="p14" href="#p14">14</a><em>Complexity:</em> Constant time if <code class="sh_cpp">&amp;x == this</code>; otherwise, linear time.</p>

<h5><code class="sh_cpp">                           void <dfn>remove</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="remove"></object>(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);</code></h5>

<p><a class="anchor" id="p15" href="#p15">15</a><em>Effects:</em> Erases all the elements in the list referred by a list iterator <code class="sh_cpp">i</code> for which the
following conditions hold: <code class="sh_cpp">*i == value</code>, <code class="sh_cpp">pred(*i) != false</code>. Invalidates only the iterators and
references to the erased elements.</p>

<p><a class="anchor" id="p16" href="#p16">16</a><em>Throws:</em> Nothing unless an exception is thrown by <code class="sh_cpp">*i == value</code> or <code class="sh_cpp">pred(*i) !=
false</code>.</p>

<p><a class="anchor" id="p17" href="#p17">17</a><em>Remarks:</em> Stable.</p>

<p><a class="anchor" id="p18" href="#p18">18</a><em>Complexity:</em> Exactly <code class="sh_cpp">size()</code> applications of the corresponding predicate.</p>

<h5><code class="sh_cpp">                                 void <dfn>unique</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="unique"></object>();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate binary_pred);</code></h5>

<p><a class="anchor" id="p19" href="#p19">19</a><em>Effects:</em> Erases all but the first element from every consecutive group of equal elements referred to by the
iterator <code class="sh_cpp">i</code> in the range <code class="sh_cpp">[first + 1, last)</code> for which <code class="sh_cpp">*i == *(i-1)</code> (for the version
of <code class="sh_cpp">unique</code> with no arguments) or <code class="sh_cpp">pred(*i, *(i - 1))</code> (for the version of <code class="sh_cpp">unique</code>
with a predicate argument) holds. Invalidates only the iterators and references to the erased elements.</p>

<p><a class="anchor" id="p20" href="#p20">20</a><em>Throws:</em> Nothing unless an exception in thrown by <code class="sh_cpp">*i == *(i-1)</code> or <code class="sh_cpp">pred(*i, *(i -
1))</code>.</p>

<p><a class="anchor" id="p21" href="#p21">21</a><em>Complexity:</em> If the range <code class="sh_cpp">[first, last)</code> is not empty, exactly <code class="sh_cpp">(last - first) - 1</code>
applications of the corresponding predicate, otherwise no applications of the predicate.</p>

<h5><code class="sh_cpp">
                         void <dfn>merge</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="merge"></object>(list&lt;T, Allocator&gt;&amp; x);
                         void merge(list&lt;T, Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&lt;T, Allocator&gt;&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(list&lt;T, Allocator&gt;&amp;&amp; x, Compare comp);</code></h5>

<p><a class="anchor" id="p22" href="#p22">22</a><em>Requires:</em> <code class="sh_cpp">comp</code> shall define a strict weak ordering (<a title="alg.sorting" href="alg.sorting.html">25.4</a>), and both the list and the
argument list shall be sorted according to this ordering.</p>

<p><a class="anchor" id="p23" href="#p23">23</a><em>Effects:</em> If <code class="sh_cpp">(&amp;x == this)</code> does nothing; otherwise, merges the two sorted ranges
<code class="sh_cpp">[begin(), end())</code> and <code class="sh_cpp">[x.begin(), x.end())</code>. The result is a range in which the elements will be
sorted in non-decreasing order according to the ordering defined by <code class="sh_cpp">comp</code>; that is, for every iterator
<code class="sh_cpp">i</code>, in the range other than the first, the condition <code class="sh_cpp">comp(*i, *(i - 1))</code> will be false. Pointers
and references to the moved elements of <code class="sh_cpp">x</code> now refer to those same elements but as members of
<code class="sh_cpp">*this</code>. Iterators referring to the moved elements will continue to refer to their elements, but they now
behave as iterators into <code class="sh_cpp">*this</code>, not into <code class="sh_cpp">x</code>.</p>

<p><a class="anchor" id="p24" href="#p24">24</a><em>Remarks:</em> Stable. If <code class="sh_cpp">(&amp;x != this)</code> the range <code class="sh_cpp">[x.begin(), x.end())</code> is empty after
the merge. No elements are copied by this operation. The behavior is undefined if <code class="sh_cpp">this-&gt;get_allocator() !=
x.get_allocator()</code>.</p>

<p><a class="anchor" id="p25" href="#p25">25</a><em>Complexity:</em> At most <code class="sh_cpp">size() + x.size() - 1</code> applications of <code class="sh_cpp">comp</code> if <code class="sh_cpp">(&amp;x !=
this)</code>; otherwise, no applications of <code class="sh_cpp">comp</code> are performed. If an exception is thrown other than by a
comparison there are no effects.</p>

<h5><code class="sh_cpp">void <dfn>reverse</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="reverse"></object>() noexcept;</code></h5>

<p><a class="anchor" id="p26" href="#p26">26</a><em>Effects:</em> Reverses the order of the elements in the list. Does not affect the validity of iterators and
references.</p>

<p><a class="anchor" id="p27" href="#p27">27</a><em>Complexity:</em> Linear time.</p>

<h5><code class="sh_cpp">                         void <dfn>sort</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="sort"></object>();
template &lt;class Compare&gt; void sort(Compare comp);</code></h5>

<p><a class="anchor" id="p28" href="#p28">28</a><em>Requires:</em> <code class="sh_cpp">operator&lt;</code> (for the first version) or <code class="sh_cpp">comp</code> (for the second version)
shall define a strict weak ordering (<a title="alg.sorting" href="alg.sorting.html">25.4</a>).</p>

<p><a class="anchor" id="p29" href="#p29">29</a><em>Effects:</em> Sorts the list according to the <code class="sh_cpp">operator&lt;</code> or a <code class="sh_cpp">Compare</code> function object.
Does not affect the validity of iterators and references.</p>

<p><a class="anchor" id="p30" href="#p30">30</a><em>Remarks:</em> Stable.</p>

<p><a class="anchor" id="p31" href="#p31">31</a><em>Complexity:</em> Approximately <var>N</var>log(<var>N</var>) comparisons, where <code class="sh_cpp"><var>N</var> ==
size()</code>.</p>


<div><p class="footnote" id="fn268">268) As specified in <a title="" href=".html"></a>, the requirements in this Clause apply only to lists whose
allocators compare equal.</p></div>
</body>
</html>

