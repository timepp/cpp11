<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Assignment</title>
</head>
<body>
<h3>
<dfn class="label">[over.ass]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[over.ass]"></object>13.5.3 Assignment </h3>

<p><a class="anchor" id="p1" href="#p1">1</a>An assignment operator shall be implemented by a non-static member function with exactly one parameter. Because
a copy assignment operator <code class="sh_cpp">operator=</code> is implicitly declared for a class if not declared by the user
(<a title="class.copy" href="class.copy.html">12.8</a>), a base class assignment operator is always hidden by the copy assignment operator of the derived
class.</p>

<p><a class="anchor" id="p2" href="#p2">2</a>Any assignment operator, even the copy and move assignment operators, can be virtual.</p>

<div class="note">
<p>[ <em>Note:</em> For a derived class <code class="sh_cpp">D</code> with a base class <code class="sh_cpp">B</code> for which a virtual copy/move assignment
has been declared, the copy/move assignment operator in <code class="sh_cpp">D</code> does not override <code class="sh_cpp">B</code>’s virtual
copy/move assignment operator.</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">struct B {
  virtual int operator= (int);
  virtual B&amp; operator= (const B&amp;);
};
struct D : B {
  virtual int operator= (int);
  virtual D&amp; operator= (const B&amp;);
};

D dobj1;
D dobj2;
B* bptr = &amp;dobj1;
void f() {
  bptr-&gt;operator=(99);      // calls D::operator=(int)
  *bptr = 99;               // ditto
  bptr-&gt;operator=(dobj2);   // calls D::operator=(const B&amp;)
  *bptr = dobj2;            // ditto
  dobj1 = dobj2;            // calls implicitly-declared
                            // D::operator=(const D&amp;)
}</code></pre>
<p> — <em>end example</em> ]</p>
</div>
<p> — <em>end note</em> ]</p>
</div>
</body>
</html>

