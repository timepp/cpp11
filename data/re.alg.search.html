<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>regex_search</title>
</head>
<body>
<h3>
<dfn class="label">[re.alg.search]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[re.alg.search]"></object>28.11.3 <code class="sh_cpp"><dfn>regex_search</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="regex_search"></object></code> </h3>

<h4><code class="sh_cpp">template &lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p1" href="#p1">1</a><em>Requires:</em> Type <code class="sh_cpp">BidirectionalIterator</code> shall satisfy the requirements of a Bidirectional Iterator
(<a title="bidirectional.iterators" href="bidirectional.iterators.html">24.2.6</a>).</p>

<p><a class="anchor" id="p2" href="#p2">2</a><em>Effects:</em> Determines whether there is some sub-sequence within <code class="sh_cpp">[first,last)</code> that matches the
regular expression <code class="sh_cpp">e</code>. The parameter <code class="sh_cpp">flags</code> is used to control how the expression is matched
against the character sequence. Returns <code class="sh_cpp">true</code> if such a sequence exists, <code class="sh_cpp">false</code>
otherwise.</p>

<p><a class="anchor" id="p3" href="#p3">3</a><em>Postconditions:</em> <code class="sh_cpp">m.ready() == true</code> in all cases. If the function returns <code class="sh_cpp">false</code>, then
the effect on parameter <code class="sh_cpp">m</code> is unspecified except that <code class="sh_cpp">m.size()</code> returns <code class="sh_cpp">0</code> and
<code class="sh_cpp">m.empty()</code> returns <code class="sh_cpp">true</code>. Otherwise the effects on parameter <code class="sh_cpp">m</code> are given in Table <a href="re.alg.search.html#t143">143</a>.</p>

<table id="t143" class="bordered hruled padded">
<caption>Table 143 — Effects of <code class="sh_cpp">regex_search</code> algorithm</caption>
<thead><tr>
<th>Element</th>
<th>Value</th>
</tr></thead>
<tbody>
<tr>
<td><code class="sh_cpp">m.size()</code></td>
<td><code class="sh_cpp">1 + e.mark_count()</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.empty()</code></td>
<td><code class="sh_cpp">false</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.prefix().first</code></td>
<td><code class="sh_cpp">first</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.prefix().second</code></td>
<td><code class="sh_cpp">m[0].first</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.prefix().matched</code></td>
<td><code class="sh_cpp">m.prefix().first != m.prefix().second</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.suffix().first</code></td>
<td><code class="sh_cpp">m[0].second</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.suffix().second</code></td>
<td><code class="sh_cpp">last</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m.suffix().matched</code></td>
<td><code class="sh_cpp">m.suffix().first != m.suffix().second</code></td>
</tr>
<tr>
<td><code class="sh_cpp">m[0].first</code></td>
	<td>The start of the sequence of characters that matched the regular expression</td>
</tr>
<tr>
<td><code class="sh_cpp">m[0].second</code></td>
	<td>The end of the sequence of characters that matched the regular expression</td>
</tr>
<tr>
<td><code class="sh_cpp">m[0].matched</code></td>
	<td>
<code class="sh_cpp">true</code> if a match was found, and <code class="sh_cpp">false</code> otherwise.</td>
</tr>
<tr>
<td><code class="sh_cpp">m[n].first</code></td>
	<td>For all integers <code class="sh_cpp">n &lt; m.size()</code>, the start of the sequence that matched sub-expression
		<code class="sh_cpp">n</code>. Alternatively, if sub-expression <code class="sh_cpp">n</code> did not participate in the match, then
		<code class="sh_cpp">last</code>.</td>
</tr>
<tr>
<td><code class="sh_cpp">m[n].second</code></td>
	<td>For all integers <code class="sh_cpp">n &lt; m.size()</code>, the end of the sequence that matched sub-expression
		<code class="sh_cpp">n</code>. Alternatively, if sub-expression <code class="sh_cpp">n</code> did not participate in the match, then
		<code class="sh_cpp">last</code>.</td>
</tr>
</tbody>
</table>

<h4><code class="sh_cpp">template &lt;class charT, class Allocator, class traits&gt;
bool regex_search(const charT* str, match_results&lt;const charT*, Allocator&gt;&amp; m,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p4" href="#p4">4</a><em>Returns:</em> The result of <code class="sh_cpp">regex_search(str, str + char_traits&lt;charT&gt;::length(str), m, e,
flags)</code>.</p>

<h4><code class="sh_cpp">template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
  bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    match_results&lt;
                      typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                      Allocator&gt;&amp; m,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p5" href="#p5">5</a><em>Returns:</em> The result of <code class="sh_cpp">regex_search(s.begin(), s.end(), m, e, flags)</code>.</p>

<h4><code class="sh_cpp">template &lt;class BidirectionalIterator, class charT, class traits&gt;
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p6" href="#p6">6</a><em>Effects:</em> Behaves “as if” by constructing an object <code class="sh_cpp">what</code> of type
<code class="sh_cpp">match_results&lt;BidirectionalIterator&gt;</code> and then returning the result of <code class="sh_cpp">regex_search(first,
last, what, e, flags)</code>.</p>

<h4><code class="sh_cpp">template &lt;class charT, class traits&gt;
  bool regex_search(const charT* str,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p7" href="#p7">7</a><em>Returns:</em> <code class="sh_cpp">regex_search(str, str + char_traits&lt;charT&gt;::length(str), e,
flags)</code>.</p>

<h4><code class="sh_cpp">template &lt;class ST, class SA, class charT, class traits&gt;
  bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);</code></h4>

<p><a class="anchor" id="p8" href="#p8">8</a><em>Returns:</em> <code class="sh_cpp">regex_search(s.begin(), s.end(), e, flags)</code>.</p>
</body>
</html>

