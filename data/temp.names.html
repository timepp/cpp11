<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<!--[IF IE]>
	<script type="text/javascript" src="ierange.js"></script>
<![ENDIF]-->
<script type="text/javascript" src="../masha.min.js"></script>
<script type="text/javascript" src="../all_pack.js"></script>
<link rel="stylesheet" type="text/css" href="../css/masha.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<link rel="stylesheet" type="text/css" href="../styles.css">
<script type="text/javascript" src="../page.js"></script>

<title>Names of template specializations</title>
</head>
<body>
<h2>
<dfn class="label">[temp.names]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[temp.names]"></object>14.2 Names of template specializations </h2>

<p><a class="anchor" id="p1" href="#p1">1</a>A template specialization (<a title="temp.spec" href="temp.spec.html">14.7</a>) can be referred to by a <i class="nonterminal">template-id</i>:</p>

<dl>
<dt>
<dfn><i class="nonterminal">simple-template-id</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="simple-template-id"></object>:</dt>
	<dd>
<i class="nonterminal">template-name</i> <code class="sh_cpp">&lt;</code> <i class="nonterminal">template-argument-list</i><sub class="opt">opt</sub> <code class="sh_cpp">&gt;</code>
</dd>
<dt>
<dfn><i class="nonterminal">template-id</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="template-id"></object>:</dt>
	<dd><i class="nonterminal">simple-template-id</i></dd>
	<dd>
<i class="nonterminal">operator-function-id</i> <code class="sh_cpp">&lt;</code> <i class="nonterminal">template-argument-list</i><sub class="opt">opt</sub> <code class="sh_cpp">&gt;</code>
</dd>
	<dd>
<i class="nonterminal">literal-operator-id</i> <code class="sh_cpp">&lt;</code> <i class="nonterminal">template-argument-list</i><sub class="opt">opt</sub> <code class="sh_cpp">&gt;</code>
</dd>
<dt>
<dfn><i class="nonterminal">template-name</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="template-name"></object>:</dt>
	<dd><i class="nonterminal">identifier</i></dd>
<dt>
<dfn><i class="nonterminal">template-argument-list</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="template-argument-list"></object>:</dt>
	<dd>
<i class="nonterminal">template-argument</i> <code class="sh_cpp">...</code><sub class="opt">opt</sub>
</dd>
	<dd>
<i class="nonterminal">template-argument-list</i> <code class="sh_cpp">,</code> <i class="nonterminal">template-argument</i> <code class="sh_cpp">...</code><sub class="opt">opt</sub>
</dd>
<dt>
<dfn><i class="nonterminal">template-argument</i></dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="template-argument"></object>:</dt>
	<dd><i class="nonterminal">constant-expression</i></dd>
	<dd><i class="nonterminal">type-id</i></dd>
	<dd><i class="nonterminal">id-expression</i></dd>
</dl>

<p><span class="note">[ <em>Note:</em> The name lookup rules (<a title="basic.lookup" href="basic.lookup.html">3.4</a>) are used to associate the use of a name with a template declaration;
that is, to identify a name as a <i class="nonterminal">template-name</i>. — <em>end note</em> ]</span></p>

<p><a class="anchor" id="p2" href="#p2">2</a>For a <i class="nonterminal">template-name</i> to be explicitly qualified by the template arguments, the name must be known to
refer to a template.</p>

<p><a class="anchor" id="p3" href="#p3">3</a>After name lookup (<a title="basic.lookup" href="basic.lookup.html">3.4</a>) finds that a name is a <i class="nonterminal">template-name</i> or that an
<i class="nonterminal">operator-function-id</i> or a <i class="nonterminal">literal-operator-id</i> refers to a set of overloaded functions any member of
which is a function template if this is followed by a <code class="sh_cpp">&lt;</code>, the <code class="sh_cpp">&lt;</code> is always taken as the
delimiter of a <i class="nonterminal">template-argument-list</i> and never as the less-than operator. When parsing a
<i class="nonterminal">template-argument-list</i>, the first non-nested <code class="sh_cpp">&gt;</code><sup class="footnote"><a href="#fn141">141</a></sup> is taken as the ending delimiter
rather than a greater-than operator. Similarly, the first non-nested <code class="sh_cpp">&gt;&gt;</code> is treated as two consecutive
but distinct <code class="sh_cpp">&gt;</code> tokens, the first of which is taken as the end of the <i class="nonterminal">template-argument-list</i> and
completes the <i class="nonterminal">template-id</i>. <span class="note">[ <em>Note:</em> The second <code class="sh_cpp">&gt;</code> token produced by this replacement rule may
terminate an enclosing <i class="nonterminal">template-id</i> construct or it may be part of a different construct (e.g. a
cast). — <em>end note</em> ]</span></p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">template&lt;int i&gt; class X { /* … */ };

X&lt; 1&gt;2 &gt; x1;        // syntax error
X&lt;(1&gt;2)&gt; x2;        // OK

template&lt;class T&gt; class Y { /* … */ };
Y&lt;X&lt;1&gt;&gt; x3;         // OK, same as Y&lt;X&lt;1&gt; &gt; x3;
Y&lt;X&lt;6&gt;&gt;1&gt;&gt; x4;      // syntax error
Y&lt;X&lt;(6&gt;&gt;1)&gt;&gt; x5;    // OK</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p4" href="#p4">4</a>When the name of a member template specialization appears after <code class="sh_cpp">.</code> or <code class="sh_cpp">-&gt;</code> in a
<i class="nonterminal">postfix-expression</i> or after a <i class="nonterminal">nested-name-specifier</i> in a <i class="nonterminal">qualified-id</i>, and the object
expression of the <i class="nonterminal">postfix-expression</i> is type-dependent or the <i class="nonterminal">nested-name-specifier</i> in the
<i class="nonterminal">qualified-id</i> refers to a dependent type, but the name is not a member of the current instantiation
(<a title="temp.dep.type" href="temp.dep.type.html">14.6.2.1</a>), the member template name must be prefixed by the keyword <code class="sh_cpp">template</code>. Otherwise the
name is assumed to name a non-template.</p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">struct X {
  template&lt;std::size_t&gt; X* alloc();
  template&lt;std::size_t&gt; static X* adjust();
};
template&lt;class T&gt; void f(T* p) {
  T* p1 = p-&gt;alloc&lt;200&gt;();          // ill-formed: &lt; means less than
  T* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list
  T::adjust&lt;100&gt;();                 // ill-formed: &lt; means less than
  T::template adjust&lt;100&gt;();        // OK: &lt; starts template argument list
}</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p5" href="#p5">5</a>A name prefixed by the keyword <code class="sh_cpp">template</code> shall be a template-id or the name shall refer to a class
template. <span class="note">[ <em>Note:</em> The keyword <code class="sh_cpp">template</code> may not be applied to non-template members of class templates. — <em>end note</em> ]</span>
<span class="note">[ <em>Note:</em> As is the case with the <code class="sh_cpp">typename</code> prefix, the <code class="sh_cpp">template</code> prefix is allowed in cases where
it is not strictly necessary; i.e., when the <i class="nonterminal">nested-name-specifier</i> or the expression on the left of the
<code class="sh_cpp">-&gt;</code> or <code class="sh_cpp">.</code> is not dependent on a <i class="nonterminal">template-parameter</i>, or the use does not appear in
the scope of a template. — <em>end note</em> ]</span></p>

<div class="example">
<p>[ <em>Example:</em> </p>
<pre><code class="sh_cpp">template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class U&gt; void f(U);
};

template &lt;class T&gt; void f(T t) {
  A&lt;T&gt; a;
  a.template f&lt;&gt;(t);                // OK: calls template
  a.template f(t);                  // error: not a <i class="nonterminal">template-id</i>
}

template &lt;class T&gt; struct B {
  template &lt;class T2&gt; struct C { };
};

// OK: T::template C names a class template:
template &lt;class T, template &lt;class X&gt; class TT = T::template C&gt; struct D { };
D&lt;b&lt;int&gt; &gt; db;</code></pre>
<p> — <em>end example</em> ]</p>
</div>

<p><a class="anchor" id="p6" href="#p6">6</a>A <i class="nonterminal">simple-template-id</i> that names a class template specialization is a <i class="nonterminal">class-name</i> (Clause
<a title="class" href="class.html">9</a>).</p>

<p><a class="anchor" id="p7" href="#p7">7</a>A <i class="nonterminal">template-id</i> that names an alias template specialization is a <i class="nonterminal">type-name</i>.</p>


<div><p class="footnote" id="fn141">141) A <code class="sh_cpp">&gt;</code> that encloses the <i class="nonterminal">type-id</i> of a <code class="sh_cpp">dynamic_cast</code>,
<code class="sh_cpp">static_cast</code>, <code class="sh_cpp">reinterpret_cast</code> or <code class="sh_cpp">const_cast</code>, or which encloses the
<i class="nonterminal">template-argument</i>s of a subsequent <i class="nonterminal">template-id</i>, is considered nested for the purpose of this
description.</p></div>
</body>
</html>



