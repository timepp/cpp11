<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="text/javascript" src="../sh_main.js"></script>
<script type="text/javascript" src="../sh_cpp.js"></script>
<link rel="stylesheet" type="text/css" href="../styles.css">
<link rel="stylesheet" type="text/css" href="../sh_print.css">
<link rel="stylesheet" type="text/css" href="../toc.css">
<script type="text/javascript" src="../highlight.js"></script>
<title>Relational operators</title>
</head>
<body>
<h4>
<dfn class="label">[tuple.rel]</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="[tuple.rel]"></object>20.4.2.7 Relational operators </h4>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator==</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator=="></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p1" href="#p1">1</a><em>Requires:</em> For all <code class="sh_cpp">i</code>, where <code class="sh_cpp">0 &lt;= i and i &lt; sizeof...(Types)</code>,
<code class="sh_cpp">get&lt;i&gt;(t) == get&lt;i&gt;(u)</code> is a valid expression returning a type that is convertible to
<code class="sh_cpp">bool</code>. <code class="sh_cpp">sizeof...(TTypes) == sizeof...(UTypes)</code>.</p>

<p><a class="anchor" id="p2" href="#p2">2</a><em>Returns:</em> <code class="sh_cpp">true</code> iff <code class="sh_cpp">get&lt;i&gt;(t) == get&lt;i&gt;(u)</code> for all <code class="sh_cpp">i</code>. For any
two zero-length tuples <code class="sh_cpp">e</code> and <code class="sh_cpp">f</code>, <code class="sh_cpp">e == f</code> returns <code class="sh_cpp">true</code>.</p>

<p><a class="anchor" id="p3" href="#p3">3</a><em>Effects:</em> The elementary comparisons are performed in order from the zeroth index upwards. No comparisons or
element accesses are performed after the first equality comparison that evaluates to <code class="sh_cpp">false</code>.</p>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator&lt;</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator&lt;"></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p4" href="#p4">4</a><em>Requires:</em> For all <code class="sh_cpp">i</code>, where <code class="sh_cpp">0 &lt;= i</code> and <code class="sh_cpp">i &lt; sizeof...(Types)</code>,
<code class="sh_cpp">get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</code> and <code class="sh_cpp">get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</code> are valid expressions
returning types that are convertible to <code class="sh_cpp">bool</code>. <code class="sh_cpp">sizeof...(TTypes) ==
sizeof...(UTypes)</code>.</p>

<p><a class="anchor" id="p5" href="#p5">5</a><em>Returns:</em> The result of a lexicographical comparison between <code class="sh_cpp">t</code> and <code class="sh_cpp">u</code>. The result is
defined as: <code class="sh_cpp">(bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) || (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; t<sub>tail</sub> &lt;
u<sub>tail</sub> )</code>, where <code class="sh_cpp">r</code><sub>tail</sub> for some tuple <code class="sh_cpp">r</code> is a tuple containing all
but the first element of <code class="sh_cpp">r</code>. For any two zero-length tuples <code class="sh_cpp">e</code> and <code class="sh_cpp">f</code>, <code class="sh_cpp">e &lt;
f</code> returns <code class="sh_cpp">false</code>.</p>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator!=</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator!="></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p6" href="#p6">6</a><em>Returns:</em> <code class="sh_cpp">!(t == u)</code>.</p>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator&gt;</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator&gt;"></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p7" href="#p7">7</a><em>Returns:</em> <code class="sh_cpp">u &lt; t</code>.</p>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator&lt;=</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator&lt;="></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p8" href="#p8">8</a><em>Returns:</em> <code class="sh_cpp">!(u &lt; t)</code>.</p>

<h5><code class="sh_cpp">template&lt;class... TTypes, class... UTypes&gt;
  bool <dfn>operator&gt;=</dfn><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e"><param name="Keyword" value="operator&gt;="></object>(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></h5>

<p><a class="anchor" id="p9" href="#p9">9</a><em>Returns:</em> <code class="sh_cpp">!(t &lt; u)</code>.</p>

<p><a class="anchor" id="p10" href="#p10">10</a><span class="note">[ <em>Note:</em> The above definitions for comparison operators do not require <code class="sh_cpp">t</code><sub>tail</sub> (or
<code class="sh_cpp">u</code><sub>tail</sub>) to be constructed. It may not even be possible, as <code class="sh_cpp">t</code> and <code class="sh_cpp">u</code> are
not required to be copy constructible. Also, all comparison operators are short circuited; they do not perform element
accesses beyond what is required to determine the result of the comparison. — <em>end note</em> ]</span></p>
</body>
</html>

